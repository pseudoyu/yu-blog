<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.105.0"><meta charset=utf-8><title>COMP7801 Topic 2 Spatial Data Management · Pseudoyu</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><script async defer data-website-id=058488c2-18d4-498a-b683-0a898b3f6c7a src=https://data.pseudoyu.com/pseudoyu.js></script>
<script async src=https://cdn.splitbee.io/sb.js></script>
<script src=https://cdn.splitbee.io/sb-ab.js></script><meta name=description content="Spatial Data Management Concepts Spatial Data
Location data Check-in service Online Maps Location-based services Location tracking Traffic Data Spatial Databases
PostgreSQL with PostGIS Neo4J-spatial HadoopGIS Ingres GeoMesa Spatial Data Management
Spatial Database Systems Manage large collections of multidimensional objects (2D/3D) A spatial object Contains (at least) one spatial attributes that describes its location and/or geometry A spatial relation Is an organized collection of spatial objects of the same entity Spatial Data Representation"><meta name=keywords content="hugo,blockchain,programming"><link rel=canonical href=https://www.pseudoyu.com/en/2021/02/06/comp7801_topic2/><link rel=alternate href=https://www.pseudoyu.com/zh/2021/02/06/comp7801_topic2/ hreflang=zh><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css integrity=sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css integrity=sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ crossorigin=anonymous><link rel=stylesheet href=https://www.pseudoyu.com/css/den.css><link rel=stylesheet href=https://www.pseudoyu.com/css/custom.css><meta property="og:title" content="COMP7801 Topic 2 Spatial Data Management"><meta property="og:description" content="Spatial Data Management Concepts Spatial Data
Location data Check-in service Online Maps Location-based services Location tracking Traffic Data Spatial Databases
PostgreSQL with PostGIS Neo4J-spatial HadoopGIS Ingres GeoMesa Spatial Data Management
Spatial Database Systems Manage large collections of multidimensional objects (2D/3D) A spatial object Contains (at least) one spatial attributes that describes its location and/or geometry A spatial relation Is an organized collection of spatial objects of the same entity Spatial Data Representation"><meta property="og:type" content="article"><meta property="og:url" content="https://www.pseudoyu.com/en/2021/02/06/comp7801_topic2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-06T01:18:17+08:00"><meta property="article:modified_time" content="2021-02-06T01:18:17+08:00"><meta itemprop=name content="COMP7801 Topic 2 Spatial Data Management"><meta itemprop=description content="Spatial Data Management Concepts Spatial Data
Location data Check-in service Online Maps Location-based services Location tracking Traffic Data Spatial Databases
PostgreSQL with PostGIS Neo4J-spatial HadoopGIS Ingres GeoMesa Spatial Data Management
Spatial Database Systems Manage large collections of multidimensional objects (2D/3D) A spatial object Contains (at least) one spatial attributes that describes its location and/or geometry A spatial relation Is an organized collection of spatial objects of the same entity Spatial Data Representation"><meta itemprop=datePublished content="2021-02-06T01:18:17+08:00"><meta itemprop=dateModified content="2021-02-06T01:18:17+08:00"><meta itemprop=wordCount content="2424"><meta itemprop=keywords content="hku,database,comp7801,"><meta name=twitter:card content="summary"><meta name=twitter:title content="COMP7801 Topic 2 Spatial Data Management"><meta name=twitter:description content="Spatial Data Management Concepts Spatial Data
Location data Check-in service Online Maps Location-based services Location tracking Traffic Data Spatial Databases
PostgreSQL with PostGIS Neo4J-spatial HadoopGIS Ingres GeoMesa Spatial Data Management
Spatial Database Systems Manage large collections of multidimensional objects (2D/3D) A spatial object Contains (at least) one spatial attributes that describes its location and/or geometry A spatial relation Is an organized collection of spatial objects of the same entity Spatial Data Representation"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://www.pseudoyu.com/images/background.webp);background-position:50%;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.pseudoyu.com/en/><img class="mr20 header-logo-image" src=https://www.pseudoyu.com/images/fly.png alt=logo>
Pseudoyu</a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/category/ideas/>Idea</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/category/tools/>Tool</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/category/develop/>Develop</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/links/>Links</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/about/>About</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/search/>Search</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/><i class="fas fa-globe"></i> 中文</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>COMP7801 Topic 2 Spatial Data Management</h1><p class=header-date>Author:
pseudoyu
| <span>2424 words, 12 minutes</span>
| <span data-cusdis-count-page-id=8285dc1ee12126897d91909e60b47cb7>0</span> comments
| 2021-02-06
| Category:
<a href=https://www.pseudoyu.com/en/category/develop/>Develop</a></p><div class=header-underline></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.pseudoyu.com/en/tag/comp7801/>comp7801</a>,
<a href=https://www.pseudoyu.com/en/tag/database/>database</a>,
<a href=https://www.pseudoyu.com/en/tag/hku/>hku</a></p><div class=clearfix></div><p class="float-right translations"><i class="fas fa-language" aria-hidden=true></i>
Translations:
<a href=https://www.pseudoyu.com/zh/2021/02/06/comp7801_topic2/>ZH</a></p></div></div></div></div></div><main><div class="container content"><articl data-pagefind-body><h2 id=spatial-data-management>Spatial Data Management</h2><h3 id=concepts>Concepts</h3><p><strong>Spatial Data</strong></p><ul><li>Location data<ul><li>Check-in service</li><li>Online Maps</li><li>Location-based services</li></ul></li><li>Location tracking</li><li>Traffic Data</li></ul><p><strong>Spatial Databases</strong></p><ul><li>PostgreSQL with PostGIS</li><li>Neo4J-spatial</li><li>HadoopGIS</li><li>Ingres</li><li>GeoMesa</li></ul><p><strong>Spatial Data Management</strong></p><ul><li>Spatial Database Systems<ul><li>Manage large collections of multidimensional objects (2D/3D)</li></ul></li><li>A spatial object<ul><li>Contains (at least) one spatial attributes that describes its location and/or geometry</li></ul></li><li>A spatial relation<ul><li>Is an organized collection of spatial objects of the same entity</li></ul></li></ul><h3 id=spatial-data>Spatial Data</h3><p><strong>Representation</strong></p><ul><li>Points (Cities in large-scale map)</li><li>Extent (rivers, forest, etc.)<ul><li>Vector (approximation by geometric objects)</li><li>Raster (A set of pixels in the grid)</li></ul></li></ul><p><strong>Application</strong></p><ul><li>Spatial data<ul><li>GIS</li><li>Segemented images</li><li>Components of CAD constructs or VLSI circuit</li><li>Stars on the sky</li><li>&mldr;</li></ul></li><li>Spatial database<ul><li>Users of mobile devices</li><li>Geographers, life scientists</li><li>&mldr;</li></ul></li></ul><h4 id=features-of-spatial>Features of spatial</h4><ul><li>Dimensionality<ul><li>There is no total ordering of objects in the multidimensional space that preserves spatial proximity</li></ul></li><li>Complex spatial extent</li><li>No standard definitions of spatial operations and algebra</li></ul><p>Relationa indexes (like B+ trees) and query processing methods (sort-merge join, hash-join) are not applicable</p><p>Spatial access methods (SAMs) for spatial data have to be defined</p><ul><li>Index spatial objects</li><li>Facilitate efficient processing of simple spatial query types (e.g. range queries)</li></ul><h3 id=spatial-relationships>Spatial Relationships</h3><p>A spatial relationship associates two objects according to their relative location and extent in space. Sometimes also called &ldquo;spatial relations&rdquo;.</p><p>Can refer to a database relation which stores spatial objects.</p><p><strong>Classification</strong></p><ul><li>Topological relationships</li><li>Distance relationships</li><li>Directional relationships</li></ul><h4 id=topological-relationships>Topological relationships</h4><p>Each object is characterized by the space it occupies in the universe (A set of pixels).</p><p>A set of relationsips between their boundaries and interiors</p><ul><li>Boundary</li><li>Interior (some may not have, points, line segments, etc.)</li></ul><p><strong>A hierarchy of relations</strong></p><ul><li>intersect (or overlaps)<ul><li>equals</li><li>inside</li><li>contains</li><li>adjacent</li></ul></li><li>disjoint</li></ul><h4 id=distance-relationships>Distance relationships</h4><p>Associate two objects based on their geometric (Euclidean distance), and it&rsquo;s usually abstracted into human mind.</p><p>Distance relationships are expressed either explicitly or by some abstract distance class.</p><h4 id=directional-relationships>Directional relationships</h4><p>Associates two object based on their relative orientation according to a global reference system.</p><h3 id=spatial-queries>Spatial Queries</h3><p>Applied on one (or more) spatial relations to retrieve objects staisfying some spatial relationships</p><ul><li>Nearest neighbor query</li><li>Spatial join</li><li>Range query<ul><li>Spatial selction</li><li>window query</li></ul></li></ul><h3 id=spatial-query-processing>Spatial Query Processing</h3><p>Evaluating spatial relationships on geometric data is slow.</p><p>A spatial object is approximated by its minimum bounding rectangle (MBR)</p><p><strong>Process</strong></p><ol><li>Filter: The MBR is tested against the query predicate</li><li>Refinement: The exact geometry of objects that pass the filter step is tested for qualification</li></ol><h3 id=spatial-access-methods-sams>Spatial Access Methods (SAMs)</h3><p><strong>The problem of indexing spatial data</strong></p><ul><li>No dynamic access method with good theoretical worst-case guarantees for range queries</li></ul><p>SAMs aim at the minimization of the expected cost.</p><ul><li>Indexing of multidimensional points</li></ul><h4 id=point-access-methods>Point access methods</h4><p>Divide the apce into disjoint partitions and group the points according to the regions they belong</p><p><img src=https://image.pseudoyu.com/images/point_access_methods.png alt=point_access_methods></p><p>Not effective for extended objects (may need to be clipped into several parts which leads to data redundancy and affects performance negatively).</p><p>Object clipping can be avoided if we allow the regions of object to overlap.</p><p><img src=https://image.pseudoyu.com/images/object_clipping.png alt=object_clipping></p><p><strong>Optimization</strong></p><ul><li>Group the objects below into 3 groups of 4 objects each such that the MBRs of the groups have the minimum overlap</li></ul><p><img src=https://image.pseudoyu.com/images/overlap_region.png alt=overlap_region></p><ul><li>Hard optimization problem</li></ul><h3 id=the-r-tree>The R-tree</h3><p><strong>Concept</strong></p><ul><li>Group object MBRs to disk blocks hierarchically</li><li>Each group of object is a leaf of the tree</li><li>The MBRs of the leaf nodes are grouped to form nodes at the next level</li><li>Grouping is recursively applied at each level until a single group (the root) is formed</li></ul><p><img src=https://image.pseudoyu.com/images/R_Tree_example.png alt=R_Tree_example></p><p><strong>Elements</strong></p><ul><li>Leaf node entries: &lt;MBR, object-id>, all leaves are in same level</li><li>Non-leaf node entries: &lt;MBR, ptr>, pointing to entries</li><li>Root: have at least two children</li><li>Non-root node parameters<ul><li>M</li><li>m</li><li>m &lt;= M/2</li><li>Usually m = 0.4 M</li></ul></li></ul><h4 id=range-searching-using-an-r-tree>Range searching using an R-tree</h4><p>Range_query (query W, R-tree node n)</p><ul><li>If n is not a leaf node<ul><li>For each index entry e in n such that e.MBR intersects W<ul><li>Visit node n&rsquo; pointed by e.ptr</li><li>Range_query (W, n')</li></ul></li></ul></li><li>If n is a leaf<ul><li>For each index entry e in n such that e.MBR intersects W<ul><li>Visit object o pointed by e.object-id</li><li>Test range query against exact geometry of o; If o intersects W, report o</li></ul></li></ul></li><li>May follow multiple paths during search</li><li>Different search predicates are used for different realtionships with W</li></ul><p><img src=https://image.pseudoyu.com/images/range_search.png alt=range_search></p><h4 id=construction-of-the-r-tree>Construction of the R-tree</h4><ul><li>Dynamically constructed/maintained</li><li>Insertions/deletions interleave with search operations<ul><li>Insertion similiar to B+ Tree, but with special optimization algorithms<ul><li>Choose the path where a new MBR is inserted</li><li>Split overflow nodes</li></ul></li><li>Underflows in deletions<ul><li>Deleting the underflow leaf node</li><li>Re-insert the remaining entries</li></ul></li></ul></li></ul><h3 id=r-tree>R*-tree</h3><p>Only different in the insertion algorithm (compared to R-tree), aiming at constructing a tree of high quality</p><p><strong>A good tree</strong></p><ul><li>nodes with small MBRs</li><li>nodes with small overlap</li><li>nodes that look like squares</li><li>nodes as full as possible</li></ul><h3 id=optimization>Optimization</h3><ul><li>Minimize the area covered by an index rectangle (small area means small dead space)</li><li>Minimize overlap between node MBRs (Minimizes the number of traversed paths)</li><li>Minimize the margins of node MBRs (Square-like nodes, smaller number of intersections for a random query, better structure)</li></ul><p><img src=https://image.pseudoyu.com/images/margin_minimization.png alt=margin_minimization></p><ul><li>Optimize the storage utilization<ul><li>Nodes in tree should be filled as much as possible</li><li>Minimizes tree height and potentially decreases dead space</li></ul></li><li>Insertion heuristics (Select the path)<ul><li>Least MBR enlargement after insertion
<img src=https://image.pseudoyu.com/images/MBR_enlargement.png alt=MBR_enlargement></li><li>Least MBR overlap after insertion
<img src=https://image.pseudoyu.com/images/MBR_overlap.png alt=MBR_overlap></li></ul></li></ul><h3 id=node-spliting>Node Spliting</h3><p><strong>Determine the split axis</strong></p><ul><li>For each axis (i.e. x and y axis)<ul><li>Sum=0;</li><li>sort entries by the lower value, then by upper value</li><li>for each sorting (e.g. lower value)<ul><li>for k=m to M+1-m</li><li>place first k entries in group A, and the remaining ones in group B</li><li><ul><li>Sum = Sum + margin(A) + margin(B)</li></ul></li></ul></li></ul></li><li>Choose axis with the minimum Sum</li></ul><p><strong>Distribute entries along axis</strong></p><ul><li>Along the split axis, choose the distribution with minimum overlap</li><li>If there are multiple groupings with minimal overlap choose &lt;A,B> such that area(A)+area(B) is minimized</li></ul><h4 id=insertion-heuristics-forced-reinsert>Insertion heuristics: Forced Reinsert</h4><p><img src=https://image.pseudoyu.com/images/forced_reinsert.png alt=forced_reinsert></p><ul><li>Forced Reinsert<ul><li>When R*-tree node n overflows, instead of splitting n immediately, try to see if some entries in n could possibly fit better in another node</li><li>Find the 30% furthest entries from the center of the group</li><li>Re-insert them to the tree (not to be repeated if another overflow occurs)</li></ul></li><li>Slightly more expensive, but better tree structure:<ul><li>less overlap</li><li>more space is utilized (more full nodes)</li></ul></li></ul><h3 id=bulk-loading-r-trees>Bulk-loading R-trees</h3><p><img src=https://image.pseudoyu.com/images/bulk_loading_R_tree.png alt=bulk_loading_R_tree></p><p>Given a static set S of rectangles, build an R-tree that indexes S.</p><ul><li>Method 1: iteratively insert rectangles into an initially empty tree<ul><li>Feature<ul><li>tree reorganization is slow</li><li>tree nodes are not as full as possible: more space occupied for the tree</li></ul></li></ul></li><li>Method 2 (x-sorting): bulk-load the rectangles into the tree using some fast (sort or hash-based) process<ul><li>sort rectangles using the x-coordinate of their center</li><li>pack M consecutive rectangles in leaf nodes</li><li>build tree bottom-up</li><li>Feature<ul><li>R-tree is built fast</li><li>good space utilization</li><li>results in leaf nodes that are have long stripes as MBRs</li></ul></li></ul></li><li>Method 3 (Hilbert sorting): use a space-filling curve to order the rectangles<ul><li>much better structure, but still the nodes have large overlap</li></ul></li><li>Method 4 (sort-tile-recursive): Sort using one axis first and then groups of sqrt(n) rectangles using the other axis<ul><li>Usually the best structure compared to other bulk-loading methods</li></ul></li></ul><h3 id=k-nearest-neighbor-search>K Nearest Neighbor Search</h3><p>Given a spatial relation R, a query object q, and a number k &lt;|R|, find the k-nearest neighbors of q in R.</p><p>We can have more than one k-NN sets (with multiple possible equidistant furthest points in them).</p><h4 id=distance-measures-and-mbrs>Distance measures and MBRs</h4><p>Distances between MBRs lower-bound the distances between the corresponding objects</p><p>dist(MBR(oi),MBR(oj)) ≤ dist(oi, oj)</p><p><img src=https://image.pseudoyu.com/images/distance_mbr.png alt=distance_mbr></p><p>Distances between R-tree node MBRs lower-bound the distances between the entries in them</p><p><img src=https://image.pseudoyu.com/images/min_distance_mbr.png alt=min_distance_mbr></p><p>The distance between a query object q and an R-tree node MBR lower-bounds the distances between q and the objects indexed under this node</p><p><img src=https://image.pseudoyu.com/images/q_distance_mbr.png alt=q_distance_mbr></p><h4 id=depth-first-nn-search-using-an-r-tree>Depth-first NN search using an R-tree</h4><ol><li>Start from the root and visit the node nearest to q</li><li>Continue recursively, until a leaf node nl is visited.</li><li>Find the NN of q in nl.</li><li>Continue visiting other nodes after backtracking as long there are nodes closer to q than the current NN.</li></ol><p><img src=https://image.pseudoyu.com/images/DFNNS_code.png alt=DFNNS_code></p><ul><li>Large space can be pruned by avoiding visiting R-tree nodes and their sub-trees</li><li>Should order the entries of a node in increasing distance from q to maximize potential for a good NN found fast</li><li>Can be easily adapted for k-NN search</li><li>Requires at most one tree path to be currently in memory – good for small memory buffers<ul><li>Characteristic of all depth-first search algorithms</li><li>Recall that the range search algorithm is also DF</li></ul></li><li>However, does not visit the least possible number of nodes</li><li>Also, not incremental – more on this later&mldr;</li></ul><p><img src=https://image.pseudoyu.com/images/DFNNS_example.png alt=DFNNS_example></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>1. visit root
</span></span><span class=line><span class=cl>dist<span class=o>(</span>q,M1<span class=o>)</span>&lt;dist<span class=o>(</span>q,oNN<span class=o>)</span>
</span></span><span class=line><span class=cl>must visit node M1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>2. visit M1
</span></span><span class=line><span class=cl>dist<span class=o>(</span>q,m1<span class=o>)</span>&lt;dist<span class=o>(</span>q,oNN<span class=o>)</span>
</span></span><span class=line><span class=cl>must visit node m1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>3. visit m1
</span></span><span class=line><span class=cl>check a,b,c
</span></span><span class=line><span class=cl>found new NN:
</span></span><span class=line><span class=cl><span class=nv>oNN</span> <span class=o>=</span> a, dist<span class=o>(</span>q,oNN<span class=o>)</span> <span class=o>=</span> sqrt<span class=o>(</span>5<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>4. backtrack to M1
</span></span><span class=line><span class=cl>check m2dist<span class=o>(</span>q,m2<span class=o>)</span> <span class=o>=</span> <span class=m>3</span> &gt;<span class=o>=</span> sqrt<span class=o>(</span>5<span class=o>)</span>:
</span></span><span class=line><span class=cl>No need to visit node m2
</span></span><span class=line><span class=cl>check m3dist<span class=o>(</span>q,m3<span class=o>)</span> <span class=o>=</span> sqrt<span class=o>(</span>5<span class=o>)</span> &gt;<span class=o>=</span> sqrt<span class=o>(</span>5<span class=o>)</span>:
</span></span><span class=line><span class=cl>No need to visit node m3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>5. backtrack to root
</span></span><span class=line><span class=cl>check M2dist<span class=o>(</span>q,M2<span class=o>)</span> <span class=o>=</span> sqrt<span class=o>(</span>2<span class=o>)</span> &lt; sqrt<span class=o>(</span>5<span class=o>)</span>:
</span></span><span class=line><span class=cl>must visit node M2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>6. visit M2
</span></span><span class=line><span class=cl>check m4dist<span class=o>(</span>q,m4<span class=o>)</span> <span class=o>=</span> sqrt<span class=o>(</span>2<span class=o>)</span> &lt; sqrt<span class=o>(</span>5<span class=o>)</span>:
</span></span><span class=line><span class=cl>must visit node m4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>7. visit m4
</span></span><span class=line><span class=cl>check i,j,k
</span></span><span class=line><span class=cl>found new NN:
</span></span><span class=line><span class=cl><span class=nv>oNN</span> <span class=o>=</span> k, dist<span class=o>(</span>q,oNN<span class=o>)</span> <span class=o>=</span> sqrt<span class=o>(</span>2<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>8. backtrack to M2
</span></span><span class=line><span class=cl>check m5dist<span class=o>(</span>q,m5<span class=o>)</span> &gt;<span class=o>=</span> sqrt<span class=o>(</span>2<span class=o>)</span>:
</span></span><span class=line><span class=cl>No need to visit node m5
</span></span><span class=line><span class=cl>check m6dist<span class=o>(</span>q,m6<span class=o>)</span> &gt;<span class=o>=</span> sqrt<span class=o>(</span>2<span class=o>)</span>:
</span></span><span class=line><span class=cl>No need to visit node m6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>9. backtrack to root
</span></span><span class=line><span class=cl>check M3dist<span class=o>(</span>q,M3<span class=o>)</span> &gt;<span class=o>=</span> sqrt<span class=o>(</span>2<span class=o>)</span>:
</span></span><span class=line><span class=cl>No need to visit node M3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>10. backtrack from root
</span></span><span class=line><span class=cl>Algorithm terminates
</span></span><span class=line><span class=cl><span class=nv>oNN</span> <span class=o>=</span>k with dist<span class=o>(</span>q,oNN<span class=o>)=</span> sqrt<span class=o>(</span>2<span class=o>)</span> found
</span></span></code></pre></div><h4 id=best-first-nn-search>Best-first NN search</h4><p>Put all entries in a priority queue and always “open” the closest one, independently of the node that contains it.</p><p>Thus the best (i.e., closest) entry is always visited first.</p><ul><li>A more efficient algorithm (given large enough memory)</li><li>Optimal in the number of R-tree nodes visited for a given query q</li><li>Uses a priority queue to organize seen entries and prioritize the next node to be visited</li><li>Adaptable for k-NN search and incremental NN search</li></ul><p><img src=https://image.pseudoyu.com/images/BFNNS_code.png alt=BFNNS_code></p><ul><li>In the previous example, we have visited fewer nodes compared to DF-NN algorithm<ul><li>Only nodes whose MBR intersect the disk centered at q with radius the real NN distance are visited (see if you can you prove this)</li></ul></li><li>The algorithm can be adapted for incremental NN search<ul><li>After having found the NN can we easily (incrementally) find the next NN without starting search from the beginning?<ul><li>put objects on the heap</li><li>never prune, but wait until an object comes out</li></ul></li></ul></li><li>The algorithm can be used for k-NN search<ul><li>use a second heap to organize the NN found so far (same can be done for DF-NN)</li><li>no need if we just use the inc. version of the algorithm</li></ul></li><li>&mldr; but: The heap can grow very large until the algorithm terminates</li></ul><p><img src=https://image.pseudoyu.com/images/BFNNS_example.png alt=BFNNS_example></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>Step 1: put all entries of root on heap Q
</span></span><span class=line><span class=cl><span class=nv>Q</span> <span class=o>=</span> M1<span class=o>(</span>1<span class=o>)</span>, M2<span class=o>(</span>sqrt<span class=o>(</span>2<span class=o>))</span>, M3<span class=o>(</span>sqrt<span class=o>(</span>8<span class=o>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Step 2: get closest entry <span class=o>(</span>top element of Q<span class=o>)</span>:
</span></span><span class=line><span class=cl>M1<span class=o>(</span>1<span class=o>)</span>. Visit node M1. Put all entries of
</span></span><span class=line><span class=cl>visited node on heap Q
</span></span><span class=line><span class=cl><span class=nv>Q</span> <span class=o>=</span> M2<span class=o>(</span>sqrt<span class=o>(</span>2<span class=o>))</span>, m1<span class=o>(</span>sqrt<span class=o>(</span>5<span class=o>))</span>, M3<span class=o>(</span>sqrt<span class=o>(</span>5<span class=o>))</span>, M3<span class=o>(</span>sqrt<span class=o>(</span>8<span class=o>))</span>, m2<span class=o>(</span>3<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Step 3: get closest entry <span class=o>(</span>top element of Q<span class=o>)</span>:
</span></span><span class=line><span class=cl>M2<span class=o>(</span>sqrt<span class=o>(</span>2<span class=o>))</span>. Visit node M2. Put all entries of
</span></span><span class=line><span class=cl>visited node on heap Q
</span></span><span class=line><span class=cl><span class=nv>Q</span> <span class=o>=</span>m4<span class=o>(</span>sqrt<span class=o>(</span>2<span class=o>))</span>, m1<span class=o>(</span>sqrt<span class=o>(</span>5<span class=o>))</span>, M3<span class=o>(</span>sqrt<span class=o>(</span>5<span class=o>))</span>, M3<span class=o>(</span>sqrt<span class=o>(</span>8<span class=o>))</span>, m2<span class=o>(</span>3<span class=o>)</span>, 	m5<span class=o>(</span>sqrt<span class=o>(</span>13<span class=o>))</span>, m5<span class=o>(</span>sqrt<span class=o>(</span>17<span class=o>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Step 4: get closest entry <span class=o>(</span>top element of Q<span class=o>)</span>:
</span></span><span class=line><span class=cl>m4<span class=o>(</span>sqrt<span class=o>(</span>2<span class=o>))</span>. Visit node m4. m4 is a leaf node, so update NN <span class=k>if</span> some object in m4 is closer than the current NN:
</span></span><span class=line><span class=cl><span class=nv>oNN</span> <span class=o>=</span> k, dist<span class=o>(</span>q,oNN<span class=o>)=</span> sqrt<span class=o>(</span>2<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nv>Q</span> <span class=o>=</span>m1<span class=o>(</span>sqrt<span class=o>(</span>5<span class=o>))</span>, M3<span class=o>(</span>sqrt<span class=o>(</span>5<span class=o>))</span>, M3<span class=o>(</span>sqrt<span class=o>(</span>8<span class=o>))</span>, m2<span class=o>(</span>3<span class=o>)</span>, 	m5<span class=o>(</span>sqrt<span class=o>(</span>13<span class=o>))</span>, m5<span class=o>(</span>sqrt<span class=o>(</span>17<span class=o>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Step 5: get closest entry <span class=o>(</span>top element of Q<span class=o>)</span>:
</span></span><span class=line><span class=cl>m1<span class=o>(</span>sqrt<span class=o>(</span>5<span class=o>))</span>. Since sqrt<span class=o>(</span>5<span class=o>)</span> &gt;<span class=o>=</span> dist<span class=o>(</span>q,oNN<span class=o>)=</span> sqrt<span class=o>(</span>2<span class=o>)</span>, search stops and oNN is returned as the NN of q
</span></span></code></pre></div><p><strong>incremental NN search</strong></p><ul><li>Example 1: find the nearest large city (>10,000 residents) to my current position<ul><li>Solution 1:<ul><li>find all large cities</li><li>apply NN search on the result</li><li>could be slow if many such cities</li><li>also R-tree may not be available for large cities only</li></ul></li><li>Solution 2:<ul><li>incrementally find NN and check if the large city requirement is satisfied; if not get the next NN</li></ul></li></ul></li><li>Example 2: find the nearest hotel; see if you like it; if not get the next one; see if you like it; &mldr;</li></ul><h3 id=spatial-joins>Spatial Joins</h3><p>Most algorithms focus on the efficient processing of the filter step.</p><p>Most spatial predicates on actual objects reduce to intersection of MBRs in the filter step. Thus all algorithms consider mainly the intersect predicate.</p><p><strong>Types</strong></p><ul><li>intersection joins</li><li>Semi-join: Find the cities that intersect a river</li><li>Similarity join: Find pairs of hotels, restaurants close to each other (with distance smaller than 100m)</li><li>Closest pairs: Find the closest pair of hotels, restaurants</li><li>All-NN: For each hotel find the nearest restaurant</li><li>Iceberg distance join: Find hotels close to at least 10 restaurants</li></ul><p><strong>Three categories of spatial join algorithms</strong></p><ul><li>Both inputs are indexed (e.g., synchronized tree traversal)</li><li>One input is indexed (e.g., indexed nested loops)</li><li>Neither input is indexed (e.g., spatial hash join)</li></ul><h4 id=r-tree-intersection-join>R-tree (Intersection) Join</h4><p>Applies on two R-trees of spatial relations R and S</p><p>Node MBRs at the high level of the trees can prune object combinations to be checked</p><p>This pseudo-code version assumes that the trees have same height</p><p><img src=https://image.pseudoyu.com/images/R_tree_join_code.png alt=R_tree_join_code></p><p><strong>Example</strong></p><ul><li>run for root(RA), root(RB)</li><li>for every intersecting pair there (e.g., A1, B1) run recursively for pointed nodes</li><li>intersecting pairs of leaf nodes are qualifying object MBR pairs</li></ul><p><img src=https://image.pseudoyu.com/images/R_tree_join_example.png alt=R_tree_join_example></p><h4 id=optimization-1>Optimization</h4><p><strong>space restriction</strong></p><ul><li>If an entry in n1 does not intersect the MBR of n2 it may not intersect any entry in n2.</li><li>Perform two scans in n1 and n2 to prune such entries</li></ul><p><img src=https://image.pseudoyu.com/images/R_tree_join_optimization.png alt=R_tree_join_optimization></p><p><strong>plane sweep</strong></p><ul><li>Sort entries in both nodes on their lower-x value (lower bound of x-projection)</li><li>Sweep a line to find fast all entry pairs that qualify x-intersection<ul><li>for each of them check y-intersection</li></ul></li></ul><p><img src=https://image.pseudoyu.com/images/R_tree_join_optimization2.png alt=R_tree_join_optimization2></p><ul><li>Worst-case sub-optimal. But very effective on the average</li><li>Worst-case optimal algorithms require advanced data structures for y-intersection. Large hidden constants, thus high cost for this problem size</li><li>Can be used with other spatial join algorithms</li></ul><p><strong>R-tree join</strong></p><ul><li>The most efficient algorithm (assuming that the relations are indexed)</li><li>Cannot be used for non-indexed inputs</li><li>unless we build on-the-fly R-trees</li><li>Comes with some I/O scheduling techniques for minimizing the page accesses</li></ul><h4 id=joining-non-indexed-inputs>Joining non-indexed inputs</h4><p><strong>Spatial hash join</strong></p><p><img src=https://image.pseudoyu.com/images/spatial_hash_join.png alt=spatial_hash_join></p><p><strong>Partition based spatial merge join</strong></p><p><img src=https://image.pseudoyu.com/images/spatial_merge_join.png alt=spatial_merge_join></p><p><strong>Indexed Nested Loops</strong></p><p><img src=https://image.pseudoyu.com/images/indexed_nest_loops.png alt=indexed_nest_loops></p><p><strong>Seeded tree join and Bulk-load and Match build an on-the-fly R-tree</strong></p><p><img src=https://image.pseudoyu.com/images/seeded_tree_join.png alt=seeded_tree_join></p><p><strong>Slot-index spatial join applies hash-join using the entries of a high R-tree level</strong></p><p><img src=https://image.pseudoyu.com/images/slot_index_spatial_join.png alt=slot_index_spatial_join></p><h3 id=the-refinement-step>The refinement step</h3><p><img src=https://image.pseudoyu.com/images/refinement_step.png alt=refinement_step></p><ul><li>Step 1: find MBR pairs that intersect</li><li>Step 2: compare some more detailed approximations to make conclusions (a.k.a. geometric filter)<ul><li>conservative approximations<ul><li>e.g., convex hull</li></ul></li><li>progressive approximation<ul><li>e.g., maximum enclosed rectangle</li></ul></li></ul></li></ul><p><img src=https://image.pseudoyu.com/images/refinement_detailed_approximations.png alt=refinement_detailed_approximations></p><ul><li>Step 3: if still join predicate inconclusive, perform expensive refinement step<ul><li>can be processed by computational geometry algorithms</li></ul></li><li>Multi-step processing (R-tree join as example)</li></ul><p><img src=https://image.pseudoyu.com/images/refinement_multi_step.png alt=refinement_multi_step></p></articl><h2>Related Posts</h2><dl class=row></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2021-03-06</dt><dd class=col-md-9><a href=/en/2021/03/06/comp7801_topic4/>COMP7801 Topic 4 Top-k</a></dd></dl><dt class=col-md-3>2021-02-27</dt><dd class=col-md-9><a href=/en/2021/02/27/comp7801_topic3/>COMP7801 Topic 3 Spatial Networks</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2021-01-30</dt><dd class=col-md-9><a href=/en/2021/01/30/comp7801_topic1b/>COMP7801 Topic 1b Database Indexing</a></dd></dl></dl><dt class=col-md-3>2021-01-23</dt><dd class=col-md-9><a href=/en/2021/01/23/comp7801_topic1a/>COMP7801 Topic 1a Relational Database</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><div class=author-card><div class=underline></div><div class=author-box><div class=author-image><a href=https://www.pseudoyu.com><img src=/images/author.webp alt=pseudoyu></a></div><div class=author-content><p class=author-title>Author</p><p class=author-name>pseudoyu</p><p class=author-desc>Blockchain Developer, MSc Graduate in ECIC(Electronic Commerce and Internet Computing) @ The University of Hong Kong (HKU). Love to learn and build things. <a href=https://github.com/pseudoyu>Follow me on GitHub</a></p></div></div></div><div align=center><div class=comment-underline></div></div><br><div id=cusdis_thread data-host=https://comments.pseudoyu.com data-app-id=27a61667-fd43-4a0d-934d-f45b944489ee data-page-id=8285dc1ee12126897d91909e60b47cb7 data-page-url=https://www.pseudoyu.com/en/2021/02/06/comp7801_topic2/ data-page-title="COMP7801 Topic 2 Spatial Data Management"></div><script defer src=https://comments.pseudoyu.com/js/widget/lang/zh-cn.js></script>
<script async defer src=https://comments.pseudoyu.com/js/cusdis.es.js></script>
<script defer data-host=https://comments.pseudoyu.com data-app-id=27a61667-fd43-4a0d-934d-f45b944489ee src=https://comments.pseudoyu.com/js/cusdis-count.umd.js></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Sitemap</div><ul class=list-unstyled><li><a href=https://www.pseudoyu.com/en/tags/>Tags</a></li><li><a href=https://www.pseudoyu.com/en/categories/>Categories</a></li><li><a rel=alternate type=application/rss+xml href=https://www.pseudoyu.com/en/index.xml><i class="fas fa-rss-square"></i> RSS Feed</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Social</div><ul class=list-unstyled><li><a href=https://t.me/pseudoyulife rel=noopener target=_blank>Telegram</a></li><li><a href=https://twitter.com/pseudo_yu rel=noopener target=_blank>Twitter</a></li><li><a href=https://www.instagram.com/pseudo.yu/ rel=noopener target=_blank>Instagram</a></li><li><a href=https://space.bilibili.com/5374948/ rel=noopener target=_blank>BiliBili</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Links</div><ul class=list-unstyled><li><a href=https://github.com/pseudoyu rel=noopener target=_blank>Yu's GitHub</a></li><li><a href=https://uptime.pseudoyu.com/status/services rel=noopener target=_blank>Yu's Services</a></li><li><a href=https://www.m1sty.com/ rel=noopener target=_blank>M1sty's Blog</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em><a href=https://data.pseudoyu.com/share/8YKX7FUa/pseudoyu-blog rel=noopener target=_blank>Yu's blog analytics</a></em></small><br><small><em>Powered by <a href=https://gohugo.io rel=noopener target=_blank>Hugo</a> - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>den</a></em></small><br><small><em><a href=https://www.hku.hk rel=noopener target=_blank>The University of Hong Kong</a> - <a href=https://www.cs.hku.hk rel=noopener target=_blank>CS</a></em></small><br><small>&copy;
Yu Zhang
2020 -
2023</small></p></div><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" id=scroll-top class=scroll-top accesskey=g><span class=arrow-icon></span></a>
<script>var mybutton=document.getElementById("scroll-top");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script></body></html>