<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.110.0"><meta charset=utf-8><title>COMP7801 Topic 1b Database Indexing · Pseudoyu</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><script async defer data-website-id=058488c2-18d4-498a-b683-0a898b3f6c7a src=https://data.pseudoyu.com/pseudoyu.js></script>
<script async src=https://cdn.splitbee.io/sb.js></script>
<script src=https://cdn.splitbee.io/sb-ab.js></script>
<script src=https://www.pseudoyu.com/js/snow.js defer></script><meta name=description content="Database Indexing Concepts Indexing mechanisms used to speed up access to desired data Search Key An attribute or a set of attributes used to look up records in a file An index file consists of records (called index entries) of the form search key - pointer Index files are typically much smaller than the original file Two basic kinds of indices Ordered indices: search keys are stored in sorted order Hash indices: search keys are distributed across &amp;ldquo;buckets&amp;rdquo; using a &amp;ldquo;hash function&amp;rdquo; Good Index Index quality is evaluated by several factors Access types supported by the index efficiently records with a specified value in the attribute (equality query) or records with an attribute value falling in a specified range of values (range query) Access time – query response time Insertion time – data record insertion time Deletion time – data record deletion time Space overhead – size of the index file Classification of Indexes Primary index In a sequentially ordered file, the index whose search key specifies the sequential order of the file Secondary index an index whose search key specifies an order different from the sequential order of the file Also called non-clustered index Dense index Index record appears for every search-key value in the file Sparse Index Contains index records for only some search-key values Applicable when records are sequentially ordered on search-key Less space and less maintenance overhead for insertions and deletions Generally slower than dense index for locating records Good tradeoff: sparse index with an index entry for every block in file, corresponding to least search-key value in the block Primary and Secondary Indices Secondary indices have to be dense Indices offer substantial benefits when searching for records Index is much smaller than relation file (cheap scan) Index can be ordered (fast search) When a file is modified, every index on the file must be updated Updating indices imposes overhead on database modification Indexes should be used with care Sequential scan using primary index is efficient, but a sequential scan using a secondary index is expensive Each record access may fetch a new block from disk Multilevel Index If index does not fit in memory, access becomes expensive To reduce number of disk accesses to index records, treat 1st level of index kept on disk as a sequential file and construct a sparse index on it outer index – a sparse index on 1st-level index file inner index – the 1st-level index file If even outer index is too large to fit in main memory, yet another level of index can be created, and so on B+-Tree Index Files A dynamic, multi-level index Advantage automatically reorganizes itself with small local changes, in the face of insertions and deletions Reorganization of entire file is not required to maintain performance Disadvantage of B+-trees Extra insertion and deletion overhead, space overhead Advantages of B+-trees outweigh disadvantages, and they are used extensively Basic Properties Disk-based tree structure every node of the tree is a block and has an address (block-id) on the disk Multiway tree each node has multiple children (between n/2 and n, where n/2 is the order or degree of the tree) Therefore, at least 50% of the space in a node is guaranteed to be occupied (this rule may not apply to tree root) Balanced tree all paths from the root to a leaf have the same length guarantees good search performance (to be seen later) Disjoint partition of attribute domain into ranges each sub-tree indexes a range in the attribute domain the entries of a directory node define the separators between domain intervals leaf nodes store index entries and pointers to the relation file Non-Leaf Nodes in B+-Trees Each non-leaf node contains up to n-1 search key values and up to n pointers All non-leaf nodes (except root) contain at least n/2 pointers (n/2 is sometimes called the minimum fan-out or degree) Non leaf nodes form a multi-level sparse index on the leaf nodes."><meta name=keywords content="hugo,blockchain,programming"><link rel=canonical href=https://www.pseudoyu.com/en/2021/01/30/comp7801_topic1b/><link rel=alternate href=https://www.pseudoyu.com/zh/2021/01/30/comp7801_topic1b/ hreflang=zh><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css integrity=sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css integrity=sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ crossorigin=anonymous><link rel=stylesheet href=https://www.pseudoyu.com/css/den.css><link rel=stylesheet href=https://www.pseudoyu.com/css/custom.css><meta property="og:title" content="COMP7801 Topic 1b Database Indexing"><meta property="og:description" content="Database Indexing Concepts Indexing mechanisms used to speed up access to desired data Search Key An attribute or a set of attributes used to look up records in a file An index file consists of records (called index entries) of the form search key - pointer Index files are typically much smaller than the original file Two basic kinds of indices Ordered indices: search keys are stored in sorted order Hash indices: search keys are distributed across &ldquo;buckets&rdquo; using a &ldquo;hash function&rdquo; Good Index Index quality is evaluated by several factors Access types supported by the index efficiently records with a specified value in the attribute (equality query) or records with an attribute value falling in a specified range of values (range query) Access time – query response time Insertion time – data record insertion time Deletion time – data record deletion time Space overhead – size of the index file Classification of Indexes Primary index In a sequentially ordered file, the index whose search key specifies the sequential order of the file Secondary index an index whose search key specifies an order different from the sequential order of the file Also called non-clustered index Dense index Index record appears for every search-key value in the file Sparse Index Contains index records for only some search-key values Applicable when records are sequentially ordered on search-key Less space and less maintenance overhead for insertions and deletions Generally slower than dense index for locating records Good tradeoff: sparse index with an index entry for every block in file, corresponding to least search-key value in the block Primary and Secondary Indices Secondary indices have to be dense Indices offer substantial benefits when searching for records Index is much smaller than relation file (cheap scan) Index can be ordered (fast search) When a file is modified, every index on the file must be updated Updating indices imposes overhead on database modification Indexes should be used with care Sequential scan using primary index is efficient, but a sequential scan using a secondary index is expensive Each record access may fetch a new block from disk Multilevel Index If index does not fit in memory, access becomes expensive To reduce number of disk accesses to index records, treat 1st level of index kept on disk as a sequential file and construct a sparse index on it outer index – a sparse index on 1st-level index file inner index – the 1st-level index file If even outer index is too large to fit in main memory, yet another level of index can be created, and so on B+-Tree Index Files A dynamic, multi-level index Advantage automatically reorganizes itself with small local changes, in the face of insertions and deletions Reorganization of entire file is not required to maintain performance Disadvantage of B+-trees Extra insertion and deletion overhead, space overhead Advantages of B+-trees outweigh disadvantages, and they are used extensively Basic Properties Disk-based tree structure every node of the tree is a block and has an address (block-id) on the disk Multiway tree each node has multiple children (between n/2 and n, where n/2 is the order or degree of the tree) Therefore, at least 50% of the space in a node is guaranteed to be occupied (this rule may not apply to tree root) Balanced tree all paths from the root to a leaf have the same length guarantees good search performance (to be seen later) Disjoint partition of attribute domain into ranges each sub-tree indexes a range in the attribute domain the entries of a directory node define the separators between domain intervals leaf nodes store index entries and pointers to the relation file Non-Leaf Nodes in B+-Trees Each non-leaf node contains up to n-1 search key values and up to n pointers All non-leaf nodes (except root) contain at least n/2 pointers (n/2 is sometimes called the minimum fan-out or degree) Non leaf nodes form a multi-level sparse index on the leaf nodes."><meta property="og:type" content="article"><meta property="og:url" content="https://www.pseudoyu.com/en/2021/01/30/comp7801_topic1b/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-30T01:18:17+08:00"><meta property="article:modified_time" content="2021-01-30T01:18:17+08:00"><meta itemprop=name content="COMP7801 Topic 1b Database Indexing"><meta itemprop=description content="Database Indexing Concepts Indexing mechanisms used to speed up access to desired data Search Key An attribute or a set of attributes used to look up records in a file An index file consists of records (called index entries) of the form search key - pointer Index files are typically much smaller than the original file Two basic kinds of indices Ordered indices: search keys are stored in sorted order Hash indices: search keys are distributed across &ldquo;buckets&rdquo; using a &ldquo;hash function&rdquo; Good Index Index quality is evaluated by several factors Access types supported by the index efficiently records with a specified value in the attribute (equality query) or records with an attribute value falling in a specified range of values (range query) Access time – query response time Insertion time – data record insertion time Deletion time – data record deletion time Space overhead – size of the index file Classification of Indexes Primary index In a sequentially ordered file, the index whose search key specifies the sequential order of the file Secondary index an index whose search key specifies an order different from the sequential order of the file Also called non-clustered index Dense index Index record appears for every search-key value in the file Sparse Index Contains index records for only some search-key values Applicable when records are sequentially ordered on search-key Less space and less maintenance overhead for insertions and deletions Generally slower than dense index for locating records Good tradeoff: sparse index with an index entry for every block in file, corresponding to least search-key value in the block Primary and Secondary Indices Secondary indices have to be dense Indices offer substantial benefits when searching for records Index is much smaller than relation file (cheap scan) Index can be ordered (fast search) When a file is modified, every index on the file must be updated Updating indices imposes overhead on database modification Indexes should be used with care Sequential scan using primary index is efficient, but a sequential scan using a secondary index is expensive Each record access may fetch a new block from disk Multilevel Index If index does not fit in memory, access becomes expensive To reduce number of disk accesses to index records, treat 1st level of index kept on disk as a sequential file and construct a sparse index on it outer index – a sparse index on 1st-level index file inner index – the 1st-level index file If even outer index is too large to fit in main memory, yet another level of index can be created, and so on B+-Tree Index Files A dynamic, multi-level index Advantage automatically reorganizes itself with small local changes, in the face of insertions and deletions Reorganization of entire file is not required to maintain performance Disadvantage of B+-trees Extra insertion and deletion overhead, space overhead Advantages of B+-trees outweigh disadvantages, and they are used extensively Basic Properties Disk-based tree structure every node of the tree is a block and has an address (block-id) on the disk Multiway tree each node has multiple children (between n/2 and n, where n/2 is the order or degree of the tree) Therefore, at least 50% of the space in a node is guaranteed to be occupied (this rule may not apply to tree root) Balanced tree all paths from the root to a leaf have the same length guarantees good search performance (to be seen later) Disjoint partition of attribute domain into ranges each sub-tree indexes a range in the attribute domain the entries of a directory node define the separators between domain intervals leaf nodes store index entries and pointers to the relation file Non-Leaf Nodes in B+-Trees Each non-leaf node contains up to n-1 search key values and up to n pointers All non-leaf nodes (except root) contain at least n/2 pointers (n/2 is sometimes called the minimum fan-out or degree) Non leaf nodes form a multi-level sparse index on the leaf nodes."><meta itemprop=datePublished content="2021-01-30T01:18:17+08:00"><meta itemprop=dateModified content="2021-01-30T01:18:17+08:00"><meta itemprop=wordCount content="2145"><meta itemprop=keywords content="hku,database,comp7801,"><meta name=twitter:card content="summary"><meta name=twitter:title content="COMP7801 Topic 1b Database Indexing"><meta name=twitter:description content="Database Indexing Concepts Indexing mechanisms used to speed up access to desired data Search Key An attribute or a set of attributes used to look up records in a file An index file consists of records (called index entries) of the form search key - pointer Index files are typically much smaller than the original file Two basic kinds of indices Ordered indices: search keys are stored in sorted order Hash indices: search keys are distributed across &ldquo;buckets&rdquo; using a &ldquo;hash function&rdquo; Good Index Index quality is evaluated by several factors Access types supported by the index efficiently records with a specified value in the attribute (equality query) or records with an attribute value falling in a specified range of values (range query) Access time – query response time Insertion time – data record insertion time Deletion time – data record deletion time Space overhead – size of the index file Classification of Indexes Primary index In a sequentially ordered file, the index whose search key specifies the sequential order of the file Secondary index an index whose search key specifies an order different from the sequential order of the file Also called non-clustered index Dense index Index record appears for every search-key value in the file Sparse Index Contains index records for only some search-key values Applicable when records are sequentially ordered on search-key Less space and less maintenance overhead for insertions and deletions Generally slower than dense index for locating records Good tradeoff: sparse index with an index entry for every block in file, corresponding to least search-key value in the block Primary and Secondary Indices Secondary indices have to be dense Indices offer substantial benefits when searching for records Index is much smaller than relation file (cheap scan) Index can be ordered (fast search) When a file is modified, every index on the file must be updated Updating indices imposes overhead on database modification Indexes should be used with care Sequential scan using primary index is efficient, but a sequential scan using a secondary index is expensive Each record access may fetch a new block from disk Multilevel Index If index does not fit in memory, access becomes expensive To reduce number of disk accesses to index records, treat 1st level of index kept on disk as a sequential file and construct a sparse index on it outer index – a sparse index on 1st-level index file inner index – the 1st-level index file If even outer index is too large to fit in main memory, yet another level of index can be created, and so on B+-Tree Index Files A dynamic, multi-level index Advantage automatically reorganizes itself with small local changes, in the face of insertions and deletions Reorganization of entire file is not required to maintain performance Disadvantage of B+-trees Extra insertion and deletion overhead, space overhead Advantages of B+-trees outweigh disadvantages, and they are used extensively Basic Properties Disk-based tree structure every node of the tree is a block and has an address (block-id) on the disk Multiway tree each node has multiple children (between n/2 and n, where n/2 is the order or degree of the tree) Therefore, at least 50% of the space in a node is guaranteed to be occupied (this rule may not apply to tree root) Balanced tree all paths from the root to a leaf have the same length guarantees good search performance (to be seen later) Disjoint partition of attribute domain into ranges each sub-tree indexes a range in the attribute domain the entries of a directory node define the separators between domain intervals leaf nodes store index entries and pointers to the relation file Non-Leaf Nodes in B+-Trees Each non-leaf node contains up to n-1 search key values and up to n pointers All non-leaf nodes (except root) contain at least n/2 pointers (n/2 is sometimes called the minimum fan-out or degree) Non leaf nodes form a multi-level sparse index on the leaf nodes."></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://www.pseudoyu.com/images/background.webp);background-position:50%;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.pseudoyu.com/en/><img class="mr20 header-logo-image" src=https://www.pseudoyu.com/images/fly.png alt=logo>
Pseudoyu</a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/category/ideas/>Idea</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/category/tools/>Tool</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/category/develop/>Develop</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/links/>Links</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/about/>About</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/search/>Search</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/><i class="fas fa-globe"></i> 中文</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>COMP7801 Topic 1b Database Indexing</h1><p class=header-date>Author:
pseudoyu
| <span>2145 words, 11 minutes</span>
| <span data-cusdis-count-page-id=dba5cb77fa7abbde5f0d34768bb29e01>0</span> comments
| 2021-01-30
| Category:
<a href=https://www.pseudoyu.com/en/category/develop/>Develop</a></p><div class=header-underline></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.pseudoyu.com/en/tag/comp7801/>comp7801</a>,
<a href=https://www.pseudoyu.com/en/tag/database/>database</a>,
<a href=https://www.pseudoyu.com/en/tag/hku/>hku</a></p><div class=clearfix></div><p class="float-right translations"><i class="fas fa-language" aria-hidden=true></i>
Translations:
<a href=https://www.pseudoyu.com/zh/2021/01/30/comp7801_topic1b/>ZH</a></p></div></div></div></div></div><main><div class="container content"><articl data-pagefind-body><h2 id=database-indexing>Database Indexing</h2><h3 id=concepts>Concepts</h3><ul><li>Indexing mechanisms used to speed up access to desired data</li><li>Search Key<ul><li>An attribute or a set of attributes used to look up records in a file</li></ul></li><li>An index file consists of records (called index entries) of the form <code>search key - pointer</code></li><li>Index files are typically much smaller than the original file</li><li>Two basic kinds of indices<ul><li>Ordered indices: search keys are stored in sorted order</li><li>Hash indices: search keys are distributed across &ldquo;buckets&rdquo; using a &ldquo;hash function&rdquo;</li></ul></li></ul><p><img src=https://image.pseudoyu.com/images/indexing_example.png alt=indexing_example></p><h3 id=good-index>Good Index</h3><ul><li>Index quality is evaluated by several factors<ul><li>Access types supported by the index efficiently<ul><li>records with a specified value in the attribute (equality query)</li><li>or records with an attribute value falling in a specified range of values (range query)</li></ul></li><li>Access time – query response time</li><li>Insertion time – data record insertion time</li><li>Deletion time – data record deletion time</li><li>Space overhead – size of the index file</li></ul></li></ul><h3 id=classification-of-indexes>Classification of Indexes</h3><ul><li>Primary index<ul><li>In a sequentially ordered file, the index whose search key specifies the sequential order of the file</li></ul></li><li>Secondary index<ul><li>an index whose search key specifies an order different from the sequential order of the file</li><li>Also called non-clustered index</li></ul></li></ul><p><img src=https://image.pseudoyu.com/images/classification_of_indexing.png alt=classification_of_indexing></p><ul><li>Dense index<ul><li>Index record appears for every search-key value in the file</li></ul></li><li>Sparse Index<ul><li>Contains index records for only some search-key values</li><li>Applicable when records are sequentially ordered on search-key</li><li>Less space and less maintenance overhead for insertions and deletions</li><li>Generally slower than dense index for locating records</li><li>Good tradeoff: sparse index with an index entry for every block in file, corresponding to least search-key value in the block</li></ul></li></ul><p><img src=https://image.pseudoyu.com/images/classification_of_indexing_2.png alt=classification_of_indexing_2></p><h4 id=primary-and-secondary-indices>Primary and Secondary Indices</h4><ul><li>Secondary indices have to be dense</li><li>Indices offer substantial benefits when searching for records<ul><li>Index is much smaller than relation file (cheap scan)</li><li>Index can be ordered (fast search)</li></ul></li><li>When a file is modified, every index on the file must be updated<ul><li>Updating indices imposes overhead on database modification</li><li>Indexes should be used with care</li></ul></li><li>Sequential scan using primary index is efficient, but a sequential scan using a secondary index is expensive<ul><li>Each record access may fetch a new block from disk</li></ul></li></ul><h3 id=multilevel-index>Multilevel Index</h3><ul><li>If index does not fit in memory, access becomes expensive</li><li>To reduce number of disk accesses to index records, treat 1st level of index kept on disk as a sequential file and construct a sparse index on it<ul><li>outer index – a sparse index on 1st-level index file</li><li>inner index – the 1st-level index file</li></ul></li><li>If even outer index is too large to fit in main memory, yet another level of index can be created, and so on</li></ul><p><img src=https://image.pseudoyu.com/images/multilevel_index_example.png alt=multilevel_index_example></p><h3 id=b-tree-index-files>B+-Tree Index Files</h3><ul><li>A dynamic, multi-level index</li><li>Advantage<ul><li>automatically reorganizes itself with small local changes, in the face of insertions and deletions</li><li>Reorganization of entire file is not required to maintain performance</li></ul></li><li>Disadvantage of B+-trees<ul><li>Extra insertion and deletion overhead, space overhead</li></ul></li><li>Advantages of B+-trees outweigh disadvantages, and they are used extensively</li></ul><h4 id=basic-properties>Basic Properties</h4><ul><li>Disk-based tree structure<ul><li>every node of the tree is a block and has an address (block-id) on the disk</li></ul></li><li>Multiway tree<ul><li>each node has multiple children (between n/2 and n, where n/2 is the order or degree of the tree)</li><li>Therefore, at least 50% of the space in a node is guaranteed to be occupied (this rule may not apply to tree root)</li></ul></li><li>Balanced tree<ul><li>all paths from the root to a leaf have the same length</li><li>guarantees good search performance (to be seen later)</li></ul></li><li>Disjoint partition of attribute domain into ranges<ul><li>each sub-tree indexes a range in the attribute domain</li><li>the entries of a directory node define the separators between domain intervals</li><li>leaf nodes store index entries and pointers to the relation file</li></ul></li></ul><p><img src=https://image.pseudoyu.com/images/B_Plus_Tree_Example.png alt=B_Plus_Tree_Example></p><h4 id=non-leaf-nodes-in-b-trees>Non-Leaf Nodes in B+-Trees</h4><ul><li>Each non-leaf node contains up to n-1 search key values and up to n pointers</li><li>All non-leaf nodes (except root) contain at least n/2 pointers (n/2 is sometimes called the minimum fan-out or degree)</li><li>Non leaf nodes form a multi-level sparse index on the leaf nodes. For a non-leaf node with m pointers<ul><li>All the search-keys in the subtree to which P1 points are less than K1</li><li>For 2 &lt;= i &lt;= n – 1, all the search-keys in the subtree to which Pi points have values greater than or equal to Ki–1 and smaller than Km–1</li></ul></li></ul><p><img src=https://image.pseudoyu.com/images/B_Plus_Tree_Non_Leaf_Node.png alt=B_Plus_Tree_Non_Leaf_Node></p><h4 id=leaf-node-in-a-b-tree>Leaf Node in a B+-Tree</h4><ul><li>Contains between (n-1)/2 and n-1 entries</li><li>Each index entry is a search key value + a record-id</li><li>If Li, Lj are leaf nodes and i &lt; j, Li’s search-key values are all smaller than Lj’s search-key values</li><li>Each leaf node is linked with a pointer to the next node</li></ul><h4 id=observations>Observations</h4><ul><li>Since the inter-node connections are done by pointers, &ldquo;logically&rdquo; close blocks need not be “physically” close<ul><li>Nodes of the tree are dynamically created/deleted, so we cannot guarantee physical closeness</li></ul></li><li>The non-leaf levels of the B+-tree form a hierarchy of sparse indices</li><li>The B+-tree contains a relatively small number of levels (logarithmic in the size of the main file), thus searches can be conducted efficiently</li><li>Insertions and deletions to the main file can be handled efficiently (in logarithmic time)</li></ul><h4 id=queries>Queries</h4><ul><li><p>Find all records with a search-key value of k</p><ul><li>Start with the root node<ul><li>Examine the node for the smallest search-key value > k</li><li>If such a value exists, assume it is Ki. Then follow Pi to the child node. (E.g. P2 is for keys in K1 &lt;= Keys &lt; K2 )</li><li>Otherwise k >= Kn–1, where there are n pointers in the node. Then follow Pn to the child node</li></ul></li><li>If the node reached by following the pointer above is not a leaf node, repeat the above procedure on the node, and follow the corresponding pointer</li><li>Eventually reach a leaf node. If for some i, key Ki = k follow pointer Pi to the desired record. Else no record with search-key value k exists</li></ul></li><li><p>In processing a query, a path is traversed in the tree from the root to some leaf node</p></li><li><p>If there are K search-key values in the file, the path is not longer than log(n/2)(K). (The degree of a node is no less than n/2)</p></li><li><p>A node has generally the same size of a disk block, typically 4 kilobytes, and n is typically around 100 (40 bytes per index entry)</p></li><li><p>With 1 million search key values and n/2 = 50, at most log50(1,000,000) = 4 nodes are accessed in a lookup</p></li><li><p>Contrast this with a balanced binary tree with 1 million search key values — around 20 nodes are accessed in a lookup</p><ul><li>(log2(1,000,000) ~= 20)</li><li>above difference is significant since every node access may need a disk I/O, costing around 10 milliseconds!</li></ul></li><li><p>Similar result for a binary search of an ordered sequential file</p></li></ul><h4 id=range-queries>Range Queries</h4><ul><li>Find all records with a search-key value between k and m (k&lt;m)<ul><li>Start with the root node<ul><li>Examine the node for the smallest search-key value > k</li><li>If such a value exists, assume it is Kj<ul><li>Then follow Pi to the child node</li></ul></li><li>Otherwise k >= Kn–1, where there are n pointers in the node<ul><li>Then follow Pn to the child node.</li></ul></li></ul></li><li>If the node reached by following the pointer above is not a leaf node, repeat the above procedure on the node, and follow the corresponding pointer</li><li>Eventually reach a leaf node. If for some i, k &lt;= Ki &lt;= m follow pointer Pi to the desired record. Continue with next entry Ki+1, while Ki+1 &lt;= m. If at end of leaf node follow pointer to next node, until Ki >m or end of index</li></ul></li></ul><p><img src=https://image.pseudoyu.com/images/B_Plus_Tree_Range_Query.png alt=B_Plus_Tree_Range_Query></p><h4 id=insertion>Insertion</h4><ul><li>Find the leaf node in which the search-key value to be inserted would appear</li><li>If the search-key value is already there in the leaf node, record is added to file and if necessary one more pointer is associated with the search key value</li><li>If the search-key value is not there, then add the record to the main file. Then<ul><li>If there is room in the leaf node, insert (key-value, pointer) pair in the leaf node</li><li>Otherwise, split the node (along with the new (key-value, pointer) entry) as discussed in the next slides</li></ul></li></ul><p><img src=https://image.pseudoyu.com/images/B_Plus_Tree_Insertion.png alt=B_Plus_Tree_Insertion></p><h4 id=splitting>Splitting</h4><ul><li>Splitting a node<ul><li>take the (search-key value, pointer) pairs (including the one being inserted) in sorted order. Place the first n/2 in the original node, and the rest in a new node</li><li>let the new node be p, and let k be the least key value in p. Insert (k,p) in the parent of the node being split. If the parent is full, split it and propagate the split further up</li></ul></li><li>The splitting of nodes proceeds upwards till a node that is not full is found. In the worst case the root node may be split increasing the height of the tree by 1</li><li>Non-leaf node splitting<ul><li>Overflown node has n+1 pointers and n values</li><li>Leave first n/2 key values and n/2+1 pointers to original node</li><li>Move last n/2 key values and n/2+1 pointers to new node</li><li>insert (middle key value, pointer to new node) to parent node</li></ul></li></ul><p><img src=https://image.pseudoyu.com/images/B_Plus_Tree_splitting.png alt=B_Plus_Tree_splitting></p><h4 id=deletion>Deletion</h4><ul><li>Find the record to be deleted, and remove it from the relation file</li><li>Remove (search-key value, record-id) of deleted record from the leaf node of the B+-tree</li><li>If the node has too few entries due to the removal, and the entries in the node and a sibling fit into a single node, then<ul><li>Insert all the search-key values in the two nodes into a single node (the one on the left), and delete the other node. (Deletion triggers a merge)</li><li>Delete the pair (Ki–1, Pi), where Pi is the pointer to the deleted node, from its parent, recursively using the above procedure</li></ul></li><li>Otherwise, if the node has too few entries due to the removal, and the entries in the node and a sibling does not fit into a single node, then<ul><li>Redistribute the pointers between the node and a sibling such that both have more than the minimum number of entries. (Deletion and rebalancing)</li><li>Update the corresponding search-key value in the parent of the node</li></ul></li><li>The node deletions may cascade upwards until a node which has n/2 or more pointers is found. If the root node has only one pointer after deletion, it is deleted and the sole child becomes the root</li></ul><p><img src=https://image.pseudoyu.com/images/B_Plus_Tree_deletion.png alt=B_Plus_Tree_deletion></p><h3 id=static-hashing>Static Hashing</h3><ul><li>A bucket is a unit of storage containing one or more records (a bucket is typically a disk block)</li><li>In a hash file organization we obtain the bucket of a record directly from its search-key value using a hash function</li><li>Hash function h is a function from the set of all search-key values K to the set of all bucket addresses B</li><li>Hash function is used to locate records for access, insertion as well as deletion</li><li>Records with different search-key values may be mapped to the same bucket; thus entire bucket has to be searched sequentially to locate a record. (Collision)</li></ul><p><img src=https://image.pseudoyu.com/images/indexing_hashing.png alt=indexing_hashing></p><h4 id=hash-function>Hash Function</h4><ul><li>Worst case has function maps all search-key values to the same bucket; this makes access time proportional to the number of search-key values in the file</li><li>An ideal hash function is uniform, i.e., each bucket is assigned the same number of search-key values from the set of all possible values</li><li>Ideal hash function is random, so each bucket will have the same number of records assigned to it irrespective of the actual distribution of search-key values in the file</li><li>Typical hash functions perform computation on the internal binary representation of the search-key<ul><li>For example, for a string search-key, the binary representations of all the characters in the string could be added and the sum modulo the number of buckets could be returned</li></ul></li></ul><h4 id=handling-of-bucket-overflows>Handling of Bucket Overflows</h4><ul><li>Bucket overflow can occur because of<ul><li>Insufficient buckets</li><li>Skew in distribution of records. This can occur due to two reasons<ul><li>multiple records have same search-key value</li><li>chosen hash function produces non-uniform distribution of key values</li></ul></li></ul></li><li>Although the probability of bucket overflow can be reduced, it cannot be eliminated; it is handled by using overflow buckets</li><li>Overflow chaining / closed hashing – the overflow buckets of a given bucket are chained together in a linked list</li></ul><h4 id=hash-indices>Hash Indices</h4><ul><li>Hashing can be used not only for file organization, but also for index-structure creation</li><li>A hash index organizes the search keys, with their associated record pointers, into a hash file structure</li></ul><p><img src=https://image.pseudoyu.com/images/Hash_Index.png alt=Hash_Index></p><h4 id=deficiencies-of-static-hashing>Deficiencies of Static Hashing</h4><ul><li>In static hashing, function h maps search-key values to a fixed set of B of bucket addresses<ul><li>Databases grow with time. If initial number of buckets is too small, performance will degrade due to too much overflows</li><li>If file size at some point in the future is anticipated and number of buckets allocated accordingly, significant amount of space will be wasted initially</li><li>If database shrinks, again space will be wasted</li><li>One option is periodic re-organization of the file with a new hash function, but it is very expensive.</li></ul></li><li>These problems can be avoided by using techniques that allow the number of buckets to be modified dynamically (dynamic hashing)</li></ul></articl><h2>Related Posts</h2><dl class=row></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2021-03-06</dt><dd class=col-md-9><a href=/en/2021/03/06/comp7801_topic4/>COMP7801 Topic 4 Top-k</a></dd></dl><dt class=col-md-3>2021-02-27</dt><dd class=col-md-9><a href=/en/2021/02/27/comp7801_topic3/>COMP7801 Topic 3 Spatial Networks</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2021-02-06</dt><dd class=col-md-9><a href=/en/2021/02/06/comp7801_topic2/>COMP7801 Topic 2 Spatial Data Management</a></dd></dl></dl></dl><dt class=col-md-3>2021-01-23</dt><dd class=col-md-9><a href=/en/2021/01/23/comp7801_topic1a/>COMP7801 Topic 1a Relational Database</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><div class=author-card><div class=underline></div><div class=author-box><div class=author-image><a href=https://www.pseudoyu.com><img src=/images/author.webp alt=pseudoyu></a></div><div class=author-content><p class=author-title>Author</p><p class=author-name>pseudoyu</p><p class=author-desc>Blockchain Developer, MSc Graduate in ECIC(Electronic Commerce and Internet Computing) @ The University of Hong Kong (HKU). Love to learn and build things. <a href=https://github.com/pseudoyu>Follow me on GitHub</a></p></div></div></div><div align=center><div class=comment-underline></div></div><br><div id=cusdis_thread data-host=https://comments.pseudoyu.com data-app-id=27a61667-fd43-4a0d-934d-f45b944489ee data-page-id=dba5cb77fa7abbde5f0d34768bb29e01 data-page-url=https://www.pseudoyu.com/en/2021/01/30/comp7801_topic1b/ data-page-title="COMP7801 Topic 1b Database Indexing"></div><script defer src=https://comments.pseudoyu.com/js/widget/lang/zh-cn.js></script>
<script async defer src=https://comments.pseudoyu.com/js/cusdis.es.js></script>
<script defer data-host=https://comments.pseudoyu.com data-app-id=27a61667-fd43-4a0d-934d-f45b944489ee src=https://comments.pseudoyu.com/js/cusdis-count.umd.js></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Sitemap</div><ul class=list-unstyled><li><a href=https://www.pseudoyu.com/en/tags/>Tags</a></li><li><a href=https://www.pseudoyu.com/en/categories/>Categories</a></li><li><a rel=alternate type=application/rss+xml href=https://www.pseudoyu.com/en/index.xml><i class="fas fa-rss-square"></i> RSS Feed</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Social</div><ul class=list-unstyled><li><a href=https://t.me/pseudoyulife rel=noopener target=_blank>Telegram</a></li><li><a href=https://twitter.com/pseudo_yu rel=noopener target=_blank>Twitter</a></li><li><a href=https://www.instagram.com/pseudo.yu/ rel=noopener target=_blank>Instagram</a></li><li><a href=https://space.bilibili.com/5374948/ rel=noopener target=_blank>BiliBili</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Links</div><ul class=list-unstyled><li><a href=https://github.com/pseudoyu rel=noopener target=_blank>Yu's GitHub</a></li><li><a href=https://uptime.pseudoyu.com/status/services rel=noopener target=_blank>Yu's Services</a></li><li><a href=https://www.m1sty.com/ rel=noopener target=_blank>M1sty's Blog</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em><a href=https://data.pseudoyu.com/share/8YKX7FUa/pseudoyu-blog rel=noopener target=_blank>Yu's blog analytics</a></em></small><br><small><em>Powered by <a href=https://gohugo.io rel=noopener target=_blank>Hugo</a> - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>den</a></em></small><br><small><em><a href=https://www.hku.hk rel=noopener target=_blank>The University of Hong Kong</a> - <a href=https://www.cs.hku.hk rel=noopener target=_blank>CS</a></em></small><br><small>&copy;
Yu Zhang
2020 -
2023</small></p></div><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" id=scroll-top class=scroll-top accesskey=g><span class=arrow-icon></span></a>
<script>var mybutton=document.getElementById("scroll-top");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script></body></html>