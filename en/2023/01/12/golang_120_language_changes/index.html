<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.109.0"><meta charset=utf-8><title>[译] Go 1.20 新变化！第一部分：语言特性 · Pseudoyu</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><script async defer data-website-id=058488c2-18d4-498a-b683-0a898b3f6c7a src=https://data.pseudoyu.com/pseudoyu.js></script>
<script async src=https://cdn.splitbee.io/sb.js></script>
<script src=https://cdn.splitbee.io/sb-ab.js></script>
<script src=https://www.pseudoyu.com/js/snow.js defer></script><meta name=description content="前言 又到了 Go 发布新版本的时刻了！2022 年第一季度的 Go 1.18 是一个主版本，它在语言中增加了期待已久的泛型，同时还有许多微小功能更新与优化。202"><meta name=keywords content="hugo,blockchain,programming"><link rel=canonical href=https://www.pseudoyu.com/en/2023/01/12/golang_120_language_changes/><link rel=alternate href=https://www.pseudoyu.com/zh/2023/01/12/golang_120_language_changes/ hreflang=zh><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css integrity=sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css integrity=sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ crossorigin=anonymous><link rel=stylesheet href=https://www.pseudoyu.com/css/den.css><meta property="og:title" content="[译] Go 1.20 新变化！第一部分：语言特性"><meta property="og:description" content="前言 又到了 Go 发布新版本的时刻了！2022 年第一季度的 Go 1.18 是一个主版本，它在语言中增加了期待已久的泛型，同时还有许多微小功能更新与优化。202"><meta property="og:type" content="article"><meta property="og:url" content="https://www.pseudoyu.com/en/2023/01/12/golang_120_language_changes/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-12T11:06:04+08:00"><meta property="article:modified_time" content="2023-01-12T11:06:04+08:00"><meta itemprop=name content="[译] Go 1.20 新变化！第一部分：语言特性"><meta itemprop=description content="前言 又到了 Go 发布新版本的时刻了！2022 年第一季度的 Go 1.18 是一个主版本，它在语言中增加了期待已久的泛型，同时还有许多微小功能更新与优化。202"><meta itemprop=datePublished content="2023-01-12T11:06:04+08:00"><meta itemprop=dateModified content="2023-01-12T11:06:04+08:00"><meta itemprop=wordCount content="2313"><meta itemprop=keywords content="go,language,programming,translation,"><meta name=twitter:card content="summary"><meta name=twitter:title content="[译] Go 1.20 新变化！第一部分：语言特性"><meta name=twitter:description content="前言 又到了 Go 发布新版本的时刻了！2022 年第一季度的 Go 1.18 是一个主版本，它在语言中增加了期待已久的泛型，同时还有许多微小功能更新与优化。202"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://www.pseudoyu.com/images/background.webp);background-position:50%;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.pseudoyu.com/en/><img class="mr20 header-logo-image" src=https://www.pseudoyu.com/images/fly.png alt=logo>
Pseudoyu</a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/category/ideas/>Idea</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/category/tools/>Tool</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/category/develop/>Develop</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/links/>Links</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/about/>About</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/search/>Search</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/><i class="fas fa-globe"></i> 中文</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>[译] Go 1.20 新变化！第一部分：语言特性</h1><p class=header-date>Author:
Yu Zhang
| <span>2313 words, 5 minutes</span>
| <span data-cusdis-count-page-id=0b3800564583841899705948aa46164f>0</span> comments
| 2023-01-12
| Category:
<a href=https://www.pseudoyu.com/en/category/develop/>Develop</a></p><div class=header-underline></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.pseudoyu.com/en/tag/go/>go</a>,
<a href=https://www.pseudoyu.com/en/tag/language/>language</a>,
<a href=https://www.pseudoyu.com/en/tag/programming/>programming</a>,
<a href=https://www.pseudoyu.com/en/tag/translation/>translation</a></p><div class=clearfix></div><p class="float-right translations"><i class="fas fa-language" aria-hidden=true></i>
Translations:
<a href=https://www.pseudoyu.com/zh/2023/01/12/golang_120_language_changes/>ZH</a></p></div></div></div></div></div><main><div class="container content"><article data-pagefind-body><h2 id=前言>前言</h2><p>又到了 Go 发布新版本的时刻了！2022 年第一季度的 Go 1.18 是一个主版本，它在语言中增加了期待已久的泛型，同时还有<a href=https://blog.carlmjohnson.net/post/2021/golang-118-minor-features/>许多微小功能更新</a>与<a href=https://blog.carlmjohnson.net/post/2022/golang-118-even-more-minor-features/>优化</a>。2022 年第三季度的 Go 1.19 是一个<a href=https://blog.carlmjohnson.net/post/2022/golang-119-new-features/>比较低调的</a>版本。现在是 2023 年，Go 1.20 <a href=https://groups.google.com/g/golang-nuts/c/HMUAm5j5raw/m/va3dxBFyAgAJ>RC 版本</a>已经发布，而正式版本也即将到来，Go 团队已经发布了<a href=https://tip.golang.org/doc/go1.20>版本说明草案</a>。</p><p>在我看来，Go 1.20 的影响介于 1.18 和 1.19 之间，比 1.19 有更多的功能更新并解决了一些长期存在的问题，但没有达到 1.18 中为语言增加泛型这样的重磅规模。尽管如此，我还是要把我对“Go 1.20 的新变化”的看法分成系列三篇博文。首先，我写了 Go 1.20 中的语言变化（如下），在下一篇文章中，我将写标准库的重要变化，最后一篇将讲解 Go 1.20 中我最喜欢的对标准库的小改动。</p><h2 id=语言特性>语言特性</h2><p>那么，让我们来看看语言方面的变化。首先，对泛型的规则做了一个小小的修改。有了 Go 泛型，你可以通过一个函数获取任何 <code>map</code> 的键：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nx>keys</span><span class=p>[</span><span class=nx>K</span> <span class=nx>comparable</span><span class=p>,</span> <span class=nx>V</span> <span class=nx>any</span><span class=p>](</span><span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=nx>K</span><span class=p>]</span><span class=nx>V</span><span class=p>)</span> <span class=p>[]</span><span class=nx>K</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>keys</span> <span class=p>[]</span><span class=nx>K</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>k</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>keys</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>keys</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>keys</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在这段代码中，<code>K comparable, V any</code>为“类型约束”。这意味着 K 可以是任何 comparable 的类型，而 V 则没有类型限制。comparable 类型为数字、布尔、字符串和由 comparable 元素组成的固定大小的复合类型等。因此，K 为 int，V 为一个 bytes 切片是合法的，但 K 是一个 bytes 切片是非法的。</p><p>我说过上面的代码会给你任何 <code>map</code> 的键，但在 Go 1.18 和 1.19 中，这并不是完全正确的。如果你试图把它用在一个键值为接口类型的 <code>map</code> 上，它将不会被编译。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=nx>any</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span> <span class=c1>// ok
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>keys</span><span class=p>(</span><span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 编译器错误（Go 1.19）：any 没有实现 comparable
</span></span></span></code></pre></div><p>这个问题归结为围绕 <code>K comparable</code> 含义的解读。要作为 <code>map</code> 键使用，类型必须被 Go 编译器认为是 comparable 的。例如，这是无效的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kd>func</span><span class=p>()]</span><span class=nx>any</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 编译器错误：无效的 map 键类型 func()
</span></span></span></code></pre></div><p>然而，你可以通过使用接口来得到一个运行时错误而不是编译器错误：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=nx>any</span><span class=p>]</span><span class=nx>any</span><span class=p>)</span> <span class=c1>// 正确
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>k</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>[</span><span class=nx>k</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1</span> <span class=c1>// panic：运行时错误：哈希值为不可哈希的类型 func()
</span></span></span></code></pre></div><p>所以，像 <code>any</code> 这样的接口类型是 map 的有效键类型，但如果你试图把一个缺少有效类型定义的键放到 map 中，就会在运行时出现 panic 错误。显然，没有人希望他们的代码在运行时出现 panic 错误，但这是在 map 中允许动态类型键的唯一方法。</p><p>下面是一个从不同角度看同一问题的例子。假设我有一个这样的错误类型：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>myerr</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=nx>myerr</span><span class=p>)</span> <span class=nf>Error</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>m</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>而现在我想使用自定义的错误类型进行比较：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>err1</span> <span class=kt>error</span> <span class=p>=</span> <span class=nf>myerr</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;err1&#34;</span> <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>err2</span> <span class=kt>error</span> <span class=p>=</span> <span class=nf>myerr</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;err2&#34;</span> <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err1</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err2</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>)</span>  <span class=c1>// true true
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err1</span> <span class=o>==</span> <span class=nx>err2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// panic：运行时错误：对 main.myerr 不可比类型进行比较
</span></span></span></code></pre></div><p>正如你所看到的，一个接口值在编译时被认为是 <code>comparable</code> 类型，但是如果它被赋的值是一个“不可比类型”，则在运行时就会出现 panic。如果你试图比较两个 <code>http.Handler</code>，而它们恰好都是 <code>http.HandlerFuncs</code>，你同样可以看到这个问题。</p><p>当 Go 1.18 支持了泛型后，<a href=https://github.com/golang/go/issues/49587>大家发现</a>，由于接口在编译时被认为是 ，但可能会包含不可比较的具体类型。如果你写的泛型代码的类型约束是<code>comparable</code>，但错误的值被存储在一个接口中，就有可能出现运行时 panic。保守起见，<a href=https://github.com/golang/go/issues/50646>Go 团队决定</a>在评估（此特性）的全部影响阶段，Go 1.18 限制使用接口作为<code>comparable</code> 类型。</p><p>现在已经过了一年了，也发布了两个版本，经过大量在 <a href=https://github.com/golang/go/issues/51338>Github 上进行的冗长讨论</a>，Go 团队认为在通用代码中使用接口作为 <code>comparable</code> 类型应该是足够安全的。如果你在 Go 1.20 中运行<code>keys(map[any]any{})</code>，它可以正常运行，你不必考虑上面的任何说明。</p><hr><p>Go 1.20 中的另一个语言变化更容易解释。如果你有一个切片，现在你可以很容易地将其转换为一个固定长度的数组：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=s>&#34;b&#34;</span><span class=p>,</span> <span class=s>&#34;c&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=nb>string</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span></code></pre></div><p>如果切片比数组短，你会因越界而产生 panic：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>4</span><span class=p>]</span><span class=nb>int</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// panic: 运行时错误: 不能将长度为 3 的切片转换成长度为 4 的数组或数组指针
</span></span></span></code></pre></div><p>这源于 Go 1.17 中增加的数组指针转换特性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=s>&#34;b&#34;</span><span class=p>,</span> <span class=s>&#34;c&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>p</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>string</span><span class=p>)(</span><span class=nx>s</span><span class=p>)</span>
</span></span></code></pre></div><p>在这种情况下，p 指向 s 定义的数组，因此修改一个就会修改另一个：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=s>&#34;b&#34;</span><span class=p>,</span> <span class=s>&#34;c&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>p</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=kt>string</span><span class=p>)(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;d&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>p</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;e&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>p</span><span class=p>)</span> <span class=c1>// [d e c] &amp;[d e c]
</span></span></span></code></pre></div><p>另一方面，随着 Go 1.20 中新增的切片转换为数组特性，数组是 切片内容的副本：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=s>&#34;b&#34;</span><span class=p>,</span> <span class=s>&#34;c&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=nb>string</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;d&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;e&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// [d b c] [a e c]
</span></span></span></code></pre></div><hr><p>除了将切片转换为数组的语法外，Go 1.20 还为处理切片数据的 <code>unsafe</code> 包带来了一些新增内容。<code>reflect</code> 包一直有<a href=https://pkg.go.dev/reflect#SliceHeader>reflect.SliceHeader</a>和<a href=https://pkg.go.dev/reflect#StringHeader>reflect.StringHeader</a>，它们是 Go 中切片和字符串的运行时表示:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>SliceHeader</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>    <span class=nx>Len</span>  <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>Cap</span>  <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>StringHeader</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>    <span class=nx>Len</span>  <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>reflect.SliceHeader</code> 和 <code>reflect.StringHeader</code>都有一个 Warning 提示：“它的表示方法可能在以后的版本中改变，因此不能确保障安全或可移植”，并且在<a href=https://go-review.googlesource.com/c/go/+/401434>试图废除它们</a>。误用这些类型可能会<a href=https://github.com/golang/go/issues/40701>导致代码崩溃</a>，但是在实践中，很多程序都依赖于类似这样的切片布局，很难想象 Go 团队会在没有大量警告的情况下改变它，因为很多程序会崩溃。</p><p>为了给 Gopher 们提供一种官方支持的编写不安全代码的方式，Go 1.17 增加了<a href=https://pkg.go.dev/unsafe#Slice>unsafe.Slice</a>，它允许你把任何指针变成一个切片（不管是否是个好主意）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>obj</span> <span class=o>:=</span> <span class=kd>struct</span><span class=p>{</span> <span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>z</span> <span class=kt>int</span> <span class=p>}{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>slice</span> <span class=o>:=</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Slice</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>obj</span><span class=p>.</span><span class=nx>x</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>obj</span><span class=p>.</span><span class=nx>x</span> <span class=p>=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=nx>slice</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>obj</span><span class=p>,</span> <span class=nx>slice</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// {4 5 3} [4 5 3]
</span></span></span></code></pre></div><p>在 Go 1.20 中，还有 <a href=https://pkg.go.dev/unsafe@go1.20rc2#SliceData>unsafe.SliceData</a>（它返回一个指向切片数据的指针），<a href=https://pkg.go.dev/unsafe@go1.20rc2#String>unsafe.String</a>（它以不安全的方式通过一个 byte 指针创建字符串），以及 <a href=https://pkg.go.dev/unsafe@go1.20rc2#StringData>unsafe.StringData</a>（它以不安全的方式返回一个指向字符串数据的指针）。</p><p>这些字符串函数是额外增加的不安全方式，因为它们允许你违反 Go 的字符串不可变规则，但它也给了你很大的控制权，可以在不分配新内存的前提下转换 byte 切片。</p><p>这些工具像利刃一样，好用却很容易割伤自己。在语言中直接支持这些工具可能更好，而不是仅仅让大家使用 <code>unsafe.Pointer</code> 来祈祷它奏效。</p><p>用 Hank Hill 的话来形容，<a href=https://www.getyarn.io/yarn-clip/08e52ddd-63ee-429b-b40c-b12c8ff6670b>“无论你做什么，你都应该以正确的方式去做，即使是错误的事情。”</a></p><h2 id=文章信息>文章信息</h2><blockquote><ol><li><a href=https://blog.carlmjohnson.net/post/2023/golang-120-language-changes/>原文地址</a></li><li><a href=https://carlmjohnson.net/>原文作者：Carl M. Johnson</a></li><li><a href=https://github.com/gocn/translator/blob/master/2023/w02_golang_120_language_changes.md>本文永久链接</a></li><li><a href=https://github.com/gocn/translator>GoCN &lt;每周译 Go></a></li><li><a href=https://github.com/pseudoyu>译者：pseudoyu</a></li><li><a href=https://github.com/focozz>校对：小超人</a></li></ol></blockquote></article><h2>Related Posts</h2><dl class=row><dt class=col-md-3>2022-12-08</dt><dd class=col-md-9><a href=/en/2022/12/08/go_style_guide/>[译] Google Go 风格指南</a></dd><dt class=col-md-3>2022-09-10</dt><dd class=col-md-9><a href=/en/2022/09/10/vulnerability_management_for_go/>[译] Go 新漏洞管理工具：govulncheck</a></dd><dt class=col-md-3>2022-09-07</dt><dd class=col-md-9><a href=/en/2022/09/07/container_docker_basic/>Docker 基础与实践</a></dd><dt class=col-md-3>2022-09-05</dt><dd class=col-md-9><a href=/en/2022/09/05/database_postgres_basic/>PostgreSQL 基础与实践</a></dd><dt class=col-md-3>2022-06-06</dt><dd class=col-md-9><a href=/en/2022/06/06/golang_creators_look_back/>[译] 是什么让 Golang 如此受欢迎？语言创造者的回顾</a></dd></dl><div class=author-card><div class=underline></div><div class=author-box><div class=author-image><a href=https://www.pseudoyu.com><img src=/images/author.webp alt="Yu Zhang"></a></div><div class=author-content><p class=author-title>Author</p><p class=author-name>Yu Zhang</p><p class=author-desc>Blockchain Developer, MSc Graduate in ECIC(Electronic Commerce and Internet Computing) @ The University of Hong Kong (HKU). Love to learn and build things. <a href=https://github.com/pseudoyu>Follow me on GitHub</a></p></div></div></div><div align=center><div class=comment-underline></div></div><br><div id=cusdis_thread data-host=https://comments.pseudoyu.com data-app-id=27a61667-fd43-4a0d-934d-f45b944489ee data-page-id=0b3800564583841899705948aa46164f data-page-url=https://www.pseudoyu.com/en/2023/01/12/golang_120_language_changes/ data-page-title="[译] Go 1.20 新变化！第一部分：语言特性"></div><script defer src=https://comments.pseudoyu.com/js/widget/lang/zh-cn.js></script>
<script async defer src=https://comments.pseudoyu.com/js/cusdis.es.js></script>
<script defer data-host=https://comments.pseudoyu.com data-app-id=27a61667-fd43-4a0d-934d-f45b944489ee src=https://comments.pseudoyu.com/js/cusdis-count.umd.js></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Sitemap</div><ul class=list-unstyled><li><a href=https://www.pseudoyu.com/en/tags/>Tags</a></li><li><a href=https://www.pseudoyu.com/en/categories/>Categories</a></li><li><a rel=alternate type=application/rss+xml href=https://www.pseudoyu.com/en/index.xml><i class="fas fa-rss-square"></i> RSS Feed</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Social</div><ul class=list-unstyled><li><a href=https://t.me/pseudoyulife rel=noopener target=_blank>Telegram</a></li><li><a href=https://twitter.com/pseudo_yu rel=noopener target=_blank>Twitter</a></li><li><a href=https://www.instagram.com/pseudo.yu/ rel=noopener target=_blank>Instagram</a></li><li><a href=https://space.bilibili.com/5374948/ rel=noopener target=_blank>BiliBili</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Links</div><ul class=list-unstyled><li><a href=https://github.com/pseudoyu rel=noopener target=_blank>Yu's GitHub</a></li><li><a href=https://uptime.pseudoyu.com/status/services rel=noopener target=_blank>Yu's Services</a></li><li><a href=https://www.m1sty.com/ rel=noopener target=_blank>M1sty's Blog</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em><a href=https://data.pseudoyu.com/share/8YKX7FUa/pseudoyu-blog rel=noopener target=_blank>Yu's blog analytics</a></em></small><br><small><em>Powered by <a href=https://gohugo.io rel=noopener target=_blank>Hugo</a> - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>den</a></em></small><br><small><em><a href=https://www.hku.hk rel=noopener target=_blank>The University of Hong Kong</a> - <a href=https://www.cs.hku.hk rel=noopener target=_blank>CS</a></em></small><br><small>&copy;
Yu Zhang
2020 -
2023</small></p></div></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script></body></html>