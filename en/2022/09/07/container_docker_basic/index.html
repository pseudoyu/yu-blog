<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.105.0"><meta charset=utf-8><title>Docker Fundamentals and Practices · Pseudoyu</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><script data-goatcounter=https://stats.pseudoyu.com/count async src=//stats.pseudoyu.com/count.js></script><meta name=description content="《后来的我们 - 五月天》 Preface This is the first article in the container section of the work practice series, primarily introducing the basic knowledge and practices of Docker. As a backend developer, when I first started working, I mainly debugged locally and hadn&amp;rsquo;t really learned about Docker usage. It wasn&amp;rsquo;t until later when I began to engage with more complex underlying chain development"><meta name=keywords content="hugo,blockchain,programming"><link rel=canonical href=https://www.pseudoyu.com/en/2022/09/07/container_docker_basic/><link rel=alternate href=https://www.pseudoyu.com/zh/2022/09/07/container_docker_basic/ hreflang=zh><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css integrity=sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css integrity=sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ crossorigin=anonymous><link rel=stylesheet href=https://www.pseudoyu.com/css/den.css><link rel=stylesheet href=https://www.pseudoyu.com/css/custom.css><meta property="og:title" content="Docker Fundamentals and Practices"><meta property="og:description" content="《后来的我们 - 五月天》 Preface This is the first article in the container section of the work practice series, primarily introducing the basic knowledge and practices of Docker. As a backend developer, when I first started working, I mainly debugged locally and hadn&rsquo;t really learned about Docker usage. It wasn&rsquo;t until later when I began to engage with more complex underlying chain development"><meta property="og:type" content="article"><meta property="og:url" content="https://www.pseudoyu.com/en/2022/09/07/container_docker_basic/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-07T01:30:48+08:00"><meta property="article:modified_time" content="2022-09-07T01:30:48+08:00"><meta itemprop=name content="Docker Fundamentals and Practices"><meta itemprop=description content="《后来的我们 - 五月天》 Preface This is the first article in the container section of the work practice series, primarily introducing the basic knowledge and practices of Docker. As a backend developer, when I first started working, I mainly debugged locally and hadn&rsquo;t really learned about Docker usage. It wasn&rsquo;t until later when I began to engage with more complex underlying chain development"><meta itemprop=datePublished content="2022-09-07T01:30:48+08:00"><meta itemprop=dateModified content="2022-09-07T01:30:48+08:00"><meta itemprop=wordCount content="2143"><meta itemprop=keywords content="container,docker,devops,programming,work practice series,work,practice,backend,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker Fundamentals and Practices"><meta name=twitter:description content="《后来的我们 - 五月天》 Preface This is the first article in the container section of the work practice series, primarily introducing the basic knowledge and practices of Docker. As a backend developer, when I first started working, I mainly debugged locally and hadn&rsquo;t really learned about Docker usage. It wasn&rsquo;t until later when I began to engage with more complex underlying chain development"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://www.pseudoyu.com/images/background.webp);background-position:50%;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.pseudoyu.com/en/><img class="mr20 header-logo-image" src=https://image.pseudoyu.com/images/fly.png alt=logo>
Pseudoyu</a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/category/ideas/>Idea</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/category/tools/>Tool</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/category/develop/>Develop</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/links/>Links</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/about/>About</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/search/>Search</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/><i class="fas fa-globe"></i> 中文</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>Docker Fundamentals and Practices</h1><p class=header-date>Author:
pseudoyu
| <span>2143 words, 5 minutes</span>
| <span class=remark42__counter data-url=https://www.pseudoyu.com/en/2022/09/07/container_docker_basic/></span> comments
| 2022-09-07
| Category:
<a href=https://www.pseudoyu.com/en/category/develop/>Develop</a></p><div class=header-underline></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.pseudoyu.com/en/tag/backend/>backend</a>,
<a href=https://www.pseudoyu.com/en/tag/container/>container</a>,
<a href=https://www.pseudoyu.com/en/tag/devops/>devops</a>,
<a href=https://www.pseudoyu.com/en/tag/docker/>docker</a>,
<a href=https://www.pseudoyu.com/en/tag/practice/>practice</a>,
<a href=https://www.pseudoyu.com/en/tag/programming/>programming</a>,
<a href=https://www.pseudoyu.com/en/tag/work/>work</a>,
<a href=https://www.pseudoyu.com/en/tag/work-practice-series/>work practice series</a></p><div class=clearfix></div><p class="float-right translations"><i class="fas fa-language" aria-hidden=true></i>
Translations:
<a href=https://www.pseudoyu.com/zh/2022/09/07/container_docker_basic/>ZH</a></p></div></div></div></div></div><main><div class="container content"><articl data-pagefind-body><figure><audio controls preload=metadata><source src=/audios/here_after_us.mp3 type=audio/mpeg></audio><i><figcaption>《后来的我们 - 五月天》</figcaption></i></figure><h2 id=preface>Preface</h2><p>This is the first article in the container section of the work practice series, primarily introducing the basic knowledge and practices of Docker.</p><p>As a backend developer, when I first started working, I mainly debugged locally and hadn&rsquo;t really learned about Docker usage. It wasn&rsquo;t until later when I began to engage with more complex underlying chain development that I encountered issues. Because of the intricate dependency relationships of chains or their related tools, along with version conflict problems, configuring complex environments on local machines or servers each time became necessary. Moreover, many services and configurations needed to be redeployed after every restart, making the process cumbersome and prone to inexplicable cross-platform errors.</p><p>Therefore, I gradually began to adopt the approach of writing project-specific Dockerfiles and compiling images for subsequent development and debugging. Deployment machines only needed to install the Docker environment (and Docker Compose), without the need to install various dependencies locally, which was very convenient. Later, together with my team leader, we configured the project&rsquo;s CI/CD process based on Docker images, GitLab CI, and the k8s environment, greatly improving development and debugging efficiency.</p><p>This article will summarize Docker-related concepts and practices based on these experiences, hoping to be of some help.</p><h2 id=introduction-to-docker>Introduction to Docker</h2><p>The services we develop often run as binaries in the operating system, while Docker is a container technology that packages our application and related dependencies in a container. Containers are typically based on a lightweight Linux image and are a stack of multiple layers of images. Our application is usually at the top layer, and these dependency relationships are specified in the Dockerfile.</p><p>Using containers for deployment has many clear advantages over deploying on local machines or remote servers.</p><ol><li><p>No need to install various environments and dependencies on the operating system (except for Docker itself). If we adopt the original service startup mode, the development process would become very cumbersome, requiring constant communication between developers and operations to complete environment configuration and deployment. Moreover, if multiple services are deployed on one machine, it&rsquo;s very easy to cause dependency/version conflict issues.</p></li><li><p>Can have independent deployment environments. We build images by writing Dockerfiles for different projects, packaging the required environment and dependencies for the application in the image. This makes it convenient to run different versions of the same application, or run multiple instances of common services like MySQL. These can be managed through Docker commands or Docker Compose commands, allowing one-click startup/pause.</p></li><li><p>Docker is not strongly dependent on the version of the operating system itself. The same Docker image can run on different operating systems (Windows, macOS, different distributions of Linux), facilitating service sharing, migration, and cross-platform deployment.</p></li><li><p>Compared to virtual machines, Docker containers do not have a kernel and only contain the application layer, making them smaller in size, faster to start, and more lightweight.</p></li></ol><p>Of course, the compatibility of Docker containers is relatively poorer compared to operating systems and virtual machines. For example, VMs can run any other operating system and can meet more specific needs.</p><h2 id=basic-docker-operations>Basic Docker Operations</h2><h3 id=installing-docker>Installing Docker</h3><p>Installing Docker is simple. Download the installation package corresponding to your operating system from the <a href=https://www.docker.com>official website</a> and follow the instructions to install.</p><h4 id=macos>macOS</h4><p>For my personal macOS system, I initially installed <a href=https://www.docker.com/products/docker-desktop/>Docker Desktop</a>, which allows management of images and containers through a graphical interface. It&rsquo;s convenient but consumes more resources and is power-intensive.</p><p>Later, I tried <a href=https://github.com/abiosoft/colima>Colima</a>, a relatively lightweight container runtime environment. It&rsquo;s very convenient for local debugging on macOS systems. I recommend using it. You can install and configure the environment according to the project&rsquo;s official documentation. I installed it directly using the <code>brew</code> package management tool:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>brew install colima
</span></span></code></pre></div><p>After installation, run <code>colima start</code> to start the container, and <code>colima stop</code> to stop the container. More commands can be viewed through <code>colima --help</code>.</p><p>I started my common development environment with the following command, which you can configure according to your own needs:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>colima start -c <span class=m>8</span> -m <span class=m>16</span> -a x86_64 -p docker-amd
</span></span></code></pre></div><h4 id=centos>CentOS</h4><p>Compared to local development, Docker is more commonly used for deploying applications on servers. My frequently used operating system is <code>CentOS 7</code>, which can be installed through the <code>yum</code> package management tool:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>yum install -y yum-utils device-mapper-persistent-data lvm2
</span></span><span class=line><span class=cl>yum-config-manager  --add-repo https://download.docker.com/linux/centos/docker-ce.repo
</span></span><span class=line><span class=cl>yum install docker-ce
</span></span></code></pre></div><p>After installation, start the Docker service and configure it to start automatically on boot:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>systemctl <span class=nb>enable</span> docker
</span></span><span class=line><span class=cl>systemctl start docker
</span></span></code></pre></div><h3 id=docker-images>Docker Images</h3><p>Docker mainly has two concepts: images and containers. An image can be considered as a template for a container compiled through a Dockerfile, while a container is an instance of an image.</p><h4 id=dockerfile>Dockerfile</h4><p>We use Dockerfile to specify the environment and dependencies required for the application. Its basic format is as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> &lt;image&gt;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENV</span> <span class=nv>USERNAME</span><span class=o>=</span>admin <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=nv>PASSWORD</span><span class=o>=</span><span class=m>123456</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>RUN</span> mkdir -p &lt;app-directory&gt;<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . /&lt;app-directory&gt;<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;&lt;command&gt;&#34;</span><span class=p>,</span> <span class=s2>&#34;&lt;entrypoint file&gt;&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>After completing the Dockerfile, we can build the image using the <code>docker build</code> command in the same directory (or specify the Dockerfile):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Build image</span>
</span></span><span class=line><span class=cl>docker build -t &lt;image:tag&gt; .
</span></span></code></pre></div><h4 id=storing-and-loading-images>Storing and Loading Images</h4><p>We can store locally compiled images as <code>tar</code> packages for sharing:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker save -o &lt;image-name&gt;.tar &lt;image-name&gt;
</span></span></code></pre></div><p>When we need to use the image, we can load the tar package using the <code>docker load</code> command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker load -i &lt;image-name&gt;.tar
</span></span></code></pre></div><h4 id=uploading-and-pulling-images>Uploading and Pulling Images</h4><p>Of course, sharing through image <code>tar</code> packages is not so convenient, and some images may be very large, making transfer inconvenient. Therefore, we can use the <code>docker push</code> command to push images to the official image repository or enterprise/personal private repositories (like the project I&rsquo;m working on uses Harbor to manage images), and use the <code>docker pull</code> command to pull them.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Pull official image (shorthand)</span>
</span></span><span class=line><span class=cl>docker pull &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Pull official image (full command)</span>
</span></span><span class=line><span class=cl>docker pull docker.io/library/&lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Push image to official image repository Docker Hub</span>
</span></span><span class=line><span class=cl>docker push &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Push image to private repository (authentication required)</span>
</span></span><span class=line><span class=cl>docker tag &lt;image:tag&gt; &lt;private-repo-path&gt;/&lt;image:tag&gt;
</span></span><span class=line><span class=cl>docker push &lt;private-repo-path&gt;/&lt;image:tag&gt;
</span></span></code></pre></div><h4 id=docker-image-operations>Docker Image Operations</h4><p>For Docker images, the operations I frequently use are viewing, deleting, and renaming tags. More commands can be viewed through <code>docker image --help</code> or on the official website.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># View all images</span>
</span></span><span class=line><span class=cl>docker images
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Delete image</span>
</span></span><span class=line><span class=cl>docker rmi &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Rename image</span>
</span></span><span class=line><span class=cl>docker tag &lt;old-image:tag&gt; &lt;new-image:tag&gt;
</span></span></code></pre></div><h3 id=container-operations>Container Operations</h3><h4 id=viewing-containers>Viewing Containers</h4><p>After we start an image through Docker or Docker Compose commands, we can view the service status through the following commands:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># View running containers</span>
</span></span><span class=line><span class=cl>docker ps
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># View all containers</span>
</span></span><span class=line><span class=cl>docker ps -a
</span></span></code></pre></div><h4 id=startingstopping-instances-from-images>Starting/Stopping Instances from Images</h4><p>After we have compiled the required image through Dockerfile, we can start an image instance through the <code>docker run</code> command, and add some configurations in the command to meet our service needs. My common operations are as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Run container</span>
</span></span><span class=line><span class=cl>docker run &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Run container and specify name</span>
</span></span><span class=line><span class=cl>docker run --name &lt;server-name&gt; &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Run container in detached mode</span>
</span></span><span class=line><span class=cl>docker run -d &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Port mapping</span>
</span></span><span class=line><span class=cl>docker run -p6000:6379 &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Configure environment variables</span>
</span></span><span class=line><span class=cl>docker run -e <span class=nv>USERNAME</span><span class=o>=</span>admin -e <span class=nv>PASSWORD</span><span class=o>=</span><span class=m>123456</span> &lt;image:tag&gt;
</span></span></code></pre></div><h4 id=startingstopping-container-services>Starting/Stopping Container Services</h4><p>After we create an instance from an image, we can start/stop the container service through the following commands:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Start/restart container</span>
</span></span><span class=line><span class=cl>docker start &lt;container-id&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Pause container</span>
</span></span><span class=line><span class=cl>docker stop &lt;container-id&gt;
</span></span></code></pre></div><h4 id=viewing-logs>Viewing Logs</h4><p>After we start a service through Docker, we often need to view its running logs for debugging. We can view them through <code>docker logs</code>, with specific commands as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># View logs</span>
</span></span><span class=line><span class=cl>docker logs &lt;container-id&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># View logs in follow mode</span>
</span></span><span class=line><span class=cl>docker logs -f &lt;container-id&gt;
</span></span></code></pre></div><h4 id=entering-containers>Entering Containers</h4><p>Sometimes we need to enter the Docker container service internally for service inspection and debugging. We can enter the container through the <code>docker exec</code> command, with specific commands as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Enter specific container by id</span>
</span></span><span class=line><span class=cl>docker <span class=nb>exec</span> -it &lt;container-id&gt; &lt;command&gt;
</span></span></code></pre></div><h4 id=docker-network>Docker Network</h4><p>Docker container instances run within a network. In our previous commands, we didn&rsquo;t specify a network, so the services will run under the default network. We can view networks through the following command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># View all networks</span>
</span></span><span class=line><span class=cl>docker network ls
</span></span></code></pre></div><p>If we don&rsquo;t want to run in the default network, we can create a custom network through the following command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Create custom network</span>
</span></span><span class=line><span class=cl>docker network create &lt;network-name&gt;
</span></span></code></pre></div><p>After creating our custom network, we can specify the network through the <code>--network</code> parameter when creating container instances:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run --network &lt;network-name&gt; &lt;image:tag&gt;
</span></span></code></pre></div><h4 id=docker-data-persistence>Docker Data Persistence</h4><p>After running services with Docker instances, our data will be saved in the containers. When the containers are deleted, the data will also be deleted, which can cause data loss for some services that need to run for a long time. Therefore, we need to persist the data. I commonly use host mounting and container mounting.</p><p>We can achieve persistence by mounting a specific directory of the host machine to a directory inside the container:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Mount host directory to container directory</span>
</span></span><span class=line><span class=cl>docker run -v &lt;host-file-path&gt;:&lt;container-file-path&gt; &lt;image:tag&gt;
</span></span></code></pre></div><p>We can also use container mounting, using volumes to achieve persistence:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># You can reference the volume by name</span>
</span></span><span class=line><span class=cl><span class=c1># Docker will automatically generate a path</span>
</span></span><span class=line><span class=cl><span class=c1># Windows: C:\ProgramData\docker\volumes</span>
</span></span><span class=line><span class=cl><span class=c1># Linux: /var/lib/docker/volumes</span>
</span></span><span class=line><span class=cl><span class=c1># macOS: /var/lib/docker/volumes</span>
</span></span><span class=line><span class=cl>docker run -v &lt;volume-name&gt;:&lt;container-file-path&gt; &lt;image:tag&gt;
</span></span></code></pre></div><p>If we only need to mount and don&rsquo;t need specific file management or viewing, we can also use container anonymous mounting, not specifying a volume name, but using its automatically generated directory:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Docker will automatically generate a path</span>
</span></span><span class=line><span class=cl><span class=c1># Windows: C:\ProgramData\docker\volumes</span>
</span></span><span class=line><span class=cl><span class=c1># Linux: /var/lib/docker/volumes</span>
</span></span><span class=line><span class=cl><span class=c1># macOS: /var/lib/docker/volumes</span>
</span></span><span class=line><span class=cl>docker run -v &lt;container-file-path&gt; &lt;image:tag&gt;
</span></span></code></pre></div><h2 id=docker-compose>Docker Compose</h2><p>Docker provides rich commands for us to use, but using command-line operations is not easy to remember, and if an application depends on multiple environments/services, it requires running and managing multiple containers separately, causing inconvenience. Therefore, we can use the Docker Compose tool for management.</p><p>Docker Compose is a tool for defining and running multi-container Docker applications, which uses <code>.yaml</code> files for configuration management. In my daily work, I use Docker Compose most frequently, only using the <code>docker run</code> command to start very simple applications, which is also convenient for unified management and subsequent configuration adjustments.</p><h3 id=installation>Installation</h3><p>If you have installed Docker Desktop on macOS, it already comes with Docker Compose, which can be used directly. If it&rsquo;s a Linux system, it needs to be installed separately. Here I&rsquo;ll take <code>CentOS 7</code> as an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl -L <span class=s2>&#34;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-</span><span class=k>$(</span>uname -s<span class=k>)</span><span class=s2>-</span><span class=k>$(</span>uname -m<span class=k>)</span><span class=s2>&#34;</span> -o /usr/local/bin/docker-compose
</span></span><span class=line><span class=cl>chmod +x /usr/local/bin/docker-compose
</span></span><span class=line><span class=cl>ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
</span></span></code></pre></div><p>After installation, you can use the <code>docker-compose</code> command.</p><h3 id=configuration-management>Configuration Management</h3><p>The configuration file for Docker Compose is a <code>yaml</code> file, with its basic format as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;3&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nt>contrainer-1</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    	</span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>&lt;image-name&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span>- <span class=l>&lt;host&gt;:&lt;container&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span>- <span class=l>&lt;host-file-path&gt;:&lt;container-file-path&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span><span class=l>&lt;ENV-KEY&gt;=&lt;ENV-VALUE&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>contrainer-2</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    	</span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>&lt;image-name&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span>- <span class=l>&lt;host&gt;:&lt;container&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span>- <span class=l>&lt;volume-name-1&gt;:&lt;container-file-path&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span><span class=l>&lt;ENV-KEY&gt;=&lt;ENV-VALUE&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nt>volume-name-1</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    	</span><span class=nt>driver</span><span class=p>:</span><span class=w> </span><span class=l>local</span><span class=w>
</span></span></span></code></pre></div><p>Most of the configurations are intuitive, such as service name, image name, port mapping, file mounting, environment variables, etc.</p><p>Among them, <code>version</code> represents the version of the configuration file, <code>services</code> represents the list of services, and <code>volumes</code> represents the list of mounted volumes.</p><p>In specific <code>services</code>, <code>image</code> represents the image name, <code>ports</code> represents port mapping, <code>volumes</code> represents file mounting, <code>environment</code> represents environment variables. More configurations can be viewed according to project needs.</p><h3 id=common-commands>Common Commands</h3><h4 id=startingstopping-services>Starting/Stopping Services</h4><p>Similar to the <code>docker run</code> command, Docker Compose also provides <code>up</code> and <code>down</code> commands to start and stop services.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Start service</span>
</span></span><span class=line><span class=cl>docker-compose -f &lt;name&gt;.yaml up
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Start service in detached mode</span>
</span></span><span class=line><span class=cl>docker-compose -f &lt;name&gt;.yaml up -d
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Stop service</span>
</span></span><span class=line><span class=cl>docker-compose -f &lt;name&gt;.yaml down
</span></span></code></pre></div><h4 id=viewing-logs-1>Viewing Logs</h4><p>We can view service logs through the <code>logs</code> command.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># View logs</span>
</span></span><span class=line><span class=cl>docker-compose logs &lt;container-id&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># View logs in follow mode</span>
</span></span><span class=line><span class=cl>docker-compose logs -f &lt;container-id&gt;
</span></span></code></pre></div><h2 id=practical-operation-commands>Practical Operation Commands</h2><p>In addition to the above basic commands, I often use the following common commands.</p><h3 id=clearing-unused-containers>Clearing Unused Containers</h3><p>When our container instances exit due to configuration or program runtime errors, they will still be retained. We can view them through the <code>docker ps -a</code> command. We can clean them up through the following combined command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker rm <span class=sb>`</span>docker ps -a <span class=p>|</span> grep Exited <span class=p>|</span> awk <span class=s1>&#39;{print $1}&#39;</span><span class=sb>`</span>
</span></span></code></pre></div><h3 id=batch-import-of-local-images>Batch Import of Local Images</h3><p>When we need to import a large number of local images into a machine, it would be very troublesome to import them one by one. We can put the images in the same directory and use the following command for batch import:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=k>for</span> i in <span class=sb>`</span>ls<span class=sb>`</span><span class=p>;</span> <span class=k>do</span> docker load &lt; <span class=nv>$i</span> <span class=p>;</span> <span class=k>done</span>
</span></span></code></pre></div><h2 id=conclusion>Conclusion</h2><p>The above is my explanation of the basic knowledge and practical operations of Docker container technology. I hope it&rsquo;s helpful to you. In fact, there&rsquo;s still a lot more content about Docker. For example, in the previous project, we tried to use Docker&rsquo;s <code>Buildkit</code> feature, which greatly reduced the size of the final built image, and used <code>buildx</code> to achieve cross-platform compatibility, etc. This article aims to explain basic knowledge and commonly used commands in practice. If you&rsquo;re interested in these extended parts, I&rsquo;ll update them later.</p><h2 id=references>References</h2><blockquote><ol><li><a href=https://www.docker.com>Docker Official Website</a></li><li><a href="https://www.youtube.com/watch?v=3c-iBn73dDE">Docker Tutorial for Beginners</a></li></ol></blockquote></articl><h2>Related Posts</h2><dl class=row></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2024-08-05</dt><dd class=col-md-9><a href=/en/2024/08/05/weekly_review_20240805/>Weekly Review #67 - Reshaping My Information Input System with Follow</a></dd></dl></dl></dl><dt class=col-md-3>2024-07-30</dt><dd class=col-md-9><a href=/en/2024/07/30/weekly_review_20240730/>Weekly Review #66 - 10x Engineers, Technical Passion and Personal Toolkit</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2022-09-05</dt><dd class=col-md-9><a href=/en/2022/09/05/database_postgres_basic/>PostgreSQL Basics and Practice</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2021-03-29</dt><dd class=col-md-9><a href=/en/2021/03/29/database_mysql_basic/>MySQL Fundamentals and Practice</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><div class=author-card><div class=underline></div><div class=author-box><div class=author-image><a href=https://www.pseudoyu.com><img src=/images/author.webp alt=pseudoyu></a></div><div class=author-content><p class=author-title>Author</p><p class=author-name>pseudoyu</p><p class=author-desc>Backend & Smart Contract Developer, MSc Graduate in ECIC(Electronic Commerce and Internet Computing) @ The University of Hong Kong (HKU). Love to learn and build things. <a href=https://github.com/pseudoyu>Follow me on GitHub</a></p></div></div></div><div align=center><div class=comment-underline></div></div><br><div class=comments><div class=title><span>Comments</span>
<span class=counter><span class=remark42__counter data-url=https://www.pseudoyu.com/en/2022/09/07/container_docker_basic/></span></span></div><div id=remark42></div></div><script>var remark_config={host:"https://comments.pseudoyu.com",site_id:"pseudoyu.com",components:["embed","counter"],max_shown_comments:20,simple_view:!0,theme:"light"}</script><script>(function(){const t=window.REMARK42;if(t)t.destroy(),t.createInstance(remark_config);else for(const t of remark_config.components){var n=document,e=n.createElement("script");e.src=`${remark_config.host}/web/${t}.mjs`,e.type="module",e.defer=!0,e.setAttribute("data-no-instant",""),n.head.appendChild(e)}})()</script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Sitemap</div><ul class=list-unstyled><li><a href=https://www.pseudoyu.com/en/tags/>Tags</a></li><li><a href=https://www.pseudoyu.com/en/categories/>Categories</a></li><li><a rel=alternate type=application/rss+xml href=https://www.pseudoyu.com/en/index.xml><i class="fas fa-rss-square"></i> RSS Feed</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Social</div><ul class=list-unstyled><li><a href=https://t.me/pseudoyulife rel=noopener target=_blank>Telegram</a></li><li><a href=https://twitter.com/pseudo_yu rel=noopener target=_blank>Twitter</a></li><li><a href=https://www.instagram.com/pseudo.yu/ rel=noopener target=_blank>Instagram</a></li><li><a href=https://space.bilibili.com/5374948/ rel=noopener target=_blank>BiliBili</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Links</div><ul class=list-unstyled><li><a href=https://github.com/pseudoyu rel=noopener target=_blank>Yu's GitHub</a></li><li><a href=https://uptime.pseudoyu.com/status/services rel=noopener target=_blank>Yu's Services</a></li><li><a href=https://www.m1sty.com/ rel=noopener target=_blank>M1sty's Blog</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em><a href="https://stats.pseudoyu.com?access-token=2m1u5i2k413q0733h2a3332w3m1t6r634g1m6n" rel=noopener target=_blank>Yu's blog analytics</a></em></small><br><small><em>Powered by <a href=https://gohugo.io rel=noopener target=_blank>Hugo</a> - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>den</a></em></small><br><small><em><a href=https://www.hku.hk rel=noopener target=_blank>The University of Hong Kong</a> - <a href=https://www.cs.hku.hk rel=noopener target=_blank>CS</a></em></small><br><small>&copy;
Yu Zhang
2020 -
2024</small></p></div><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" id=scroll-top class=scroll-top accesskey=g><span class=arrow-icon></span></a>
<script>var mybutton=document.getElementById("scroll-top");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script></body></html>