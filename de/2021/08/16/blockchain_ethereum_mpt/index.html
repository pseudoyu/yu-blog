<!doctype html><html lang=de itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.105.0"><meta charset=utf-8><title>Detaillierte Erklärung des Ethereum MPT (Merkle Patricia Tries) · Pseudoyu</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><script data-goatcounter=https://stats.pseudoyu.com/count async src=//stats.pseudoyu.com/count.js></script><meta name=description content="Vorwort Kürzlich erhielt ich eine Arbeitsaufgabe, die Datenstruktur des Zustandsbaums des Projekts-Smart-Contracts von einem Rot-Schwarz-Baum in einen Trie zu ändern und die Leistung der beiden Datenstrukturen zu vergleichen. Der Trie bezieht sich hauptsächlich auf die offizielle Java-Implementierung von Ethereum ethereum/ethereumj, während der Rot-Schwarz-Baum von mir selbst implementiert wurde. Dieser Artikel ist eine Aufzeichnung des theoretischen und praktischen Vergleichs der beiden Datenstrukturen.
Datenstrukturen Rot-Schwarz-Baum Ein Rot-Schwarz-Baum ist ein annähernd ausgewogener binärer Suchbaum, der rote und schwarze Knoten enthält und sicherstellt, dass der Höhenunterschied zwischen dem linken und rechten Teilbaum eines beliebigen Knotens weniger als das Zweifache beträgt."><meta name=keywords content="hugo,blockchain,programming"><link rel=canonical href=https://www.pseudoyu.com/de/2021/08/16/blockchain_ethereum_mpt/><link rel=alternate href=https://www.pseudoyu.com/zh/2021/08/16/blockchain_ethereum_mpt/ hreflang=zh><link rel=alternate href=https://www.pseudoyu.com/en/2021/08/16/blockchain_ethereum_mpt/ hreflang=en><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css integrity=sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css integrity=sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ crossorigin=anonymous><link rel=stylesheet href=https://www.pseudoyu.com/css/den.css><link rel=stylesheet href=https://www.pseudoyu.com/css/custom.css><meta property="og:title" content="Detaillierte Erklärung des Ethereum MPT (Merkle Patricia Tries)"><meta property="og:description" content="Vorwort Kürzlich erhielt ich eine Arbeitsaufgabe, die Datenstruktur des Zustandsbaums des Projekts-Smart-Contracts von einem Rot-Schwarz-Baum in einen Trie zu ändern und die Leistung der beiden Datenstrukturen zu vergleichen. Der Trie bezieht sich hauptsächlich auf die offizielle Java-Implementierung von Ethereum ethereum/ethereumj, während der Rot-Schwarz-Baum von mir selbst implementiert wurde. Dieser Artikel ist eine Aufzeichnung des theoretischen und praktischen Vergleichs der beiden Datenstrukturen.
Datenstrukturen Rot-Schwarz-Baum Ein Rot-Schwarz-Baum ist ein annähernd ausgewogener binärer Suchbaum, der rote und schwarze Knoten enthält und sicherstellt, dass der Höhenunterschied zwischen dem linken und rechten Teilbaum eines beliebigen Knotens weniger als das Zweifache beträgt."><meta property="og:type" content="article"><meta property="og:url" content="https://www.pseudoyu.com/de/2021/08/16/blockchain_ethereum_mpt/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-16T12:12:17+08:00"><meta property="article:modified_time" content="2021-08-16T12:12:17+08:00"><meta itemprop=name content="Detaillierte Erklärung des Ethereum MPT (Merkle Patricia Tries)"><meta itemprop=description content="Vorwort Kürzlich erhielt ich eine Arbeitsaufgabe, die Datenstruktur des Zustandsbaums des Projekts-Smart-Contracts von einem Rot-Schwarz-Baum in einen Trie zu ändern und die Leistung der beiden Datenstrukturen zu vergleichen. Der Trie bezieht sich hauptsächlich auf die offizielle Java-Implementierung von Ethereum ethereum/ethereumj, während der Rot-Schwarz-Baum von mir selbst implementiert wurde. Dieser Artikel ist eine Aufzeichnung des theoretischen und praktischen Vergleichs der beiden Datenstrukturen.
Datenstrukturen Rot-Schwarz-Baum Ein Rot-Schwarz-Baum ist ein annähernd ausgewogener binärer Suchbaum, der rote und schwarze Knoten enthält und sicherstellt, dass der Höhenunterschied zwischen dem linken und rechten Teilbaum eines beliebigen Knotens weniger als das Zweifache beträgt."><meta itemprop=datePublished content="2021-08-16T12:12:17+08:00"><meta itemprop=dateModified content="2021-08-16T12:12:17+08:00"><meta itemprop=wordCount content="911"><meta itemprop=keywords content="blockchain,ethereum,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Detaillierte Erklärung des Ethereum MPT (Merkle Patricia Tries)"><meta name=twitter:description content="Vorwort Kürzlich erhielt ich eine Arbeitsaufgabe, die Datenstruktur des Zustandsbaums des Projekts-Smart-Contracts von einem Rot-Schwarz-Baum in einen Trie zu ändern und die Leistung der beiden Datenstrukturen zu vergleichen. Der Trie bezieht sich hauptsächlich auf die offizielle Java-Implementierung von Ethereum ethereum/ethereumj, während der Rot-Schwarz-Baum von mir selbst implementiert wurde. Dieser Artikel ist eine Aufzeichnung des theoretischen und praktischen Vergleichs der beiden Datenstrukturen.
Datenstrukturen Rot-Schwarz-Baum Ein Rot-Schwarz-Baum ist ein annähernd ausgewogener binärer Suchbaum, der rote und schwarze Knoten enthält und sicherstellt, dass der Höhenunterschied zwischen dem linken und rechten Teilbaum eines beliebigen Knotens weniger als das Zweifache beträgt."></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://www.pseudoyu.com/images/background.png);background-position:50%;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.pseudoyu.com/de/><img class="mr20 header-logo-image" src=https://www.pseudoyu.com/images/icon.png alt=logo>
Pseudoyu</a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/de/category/ideas/>Ideen</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/de/category/tools/>Tools</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/de/category/develop/>Code</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/de/links/>Links</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/de/search/>Suche</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/de/about/>Über</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/><i class="fas fa-globe"></i> 简</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/><i class="fas fa-globe"></i> EN</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>Detaillierte Erklärung des Ethereum MPT (Merkle Patricia Tries)</h1><p class=header-date>Autor:
pseudoyu
| <span>911 Wörter, 5 Minuten</span>
| <span class=remark42__counter data-url=https://www.pseudoyu.com/de/2021/08/16/blockchain_ethereum_mpt/></span> Kommentare
| 2021-08-16
| Kategorie:
<a href=https://www.pseudoyu.com/de/category/develop/>Develop</a></p><div class=header-underline></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.pseudoyu.com/de/tag/blockchain/>blockchain</a>,
<a href=https://www.pseudoyu.com/de/tag/ethereum/>ethereum</a></p><div class=clearfix></div><p class="float-right translations"><i class="fas fa-language" aria-hidden=true></i>
Übersetzungen:
<a href=https://www.pseudoyu.com/zh/2021/08/16/blockchain_ethereum_mpt/>ZH</a>, <a href=https://www.pseudoyu.com/en/2021/08/16/blockchain_ethereum_mpt/>EN</a></p></div></div></div></div></div><main><div class="container content"><articl data-pagefind-body><h2 id=vorwort>Vorwort</h2><p>Kürzlich erhielt ich eine Arbeitsaufgabe, die Datenstruktur des Zustandsbaums des Projekts-Smart-Contracts von einem Rot-Schwarz-Baum in einen Trie zu ändern und die Leistung der beiden Datenstrukturen zu vergleichen. Der Trie bezieht sich hauptsächlich auf die offizielle Java-Implementierung von Ethereum <a href=https://github.com/ethereum/ethereumj/tree/develop/ethereumj-core/src/main/java/org/ethereum/trie>ethereum/ethereumj</a>, während der Rot-Schwarz-Baum von mir selbst implementiert wurde. Dieser Artikel ist eine Aufzeichnung des theoretischen und praktischen Vergleichs der beiden Datenstrukturen.</p><h2 id=datenstrukturen>Datenstrukturen</h2><h3 id=rot-schwarz-baum>Rot-Schwarz-Baum</h3><p>Ein Rot-Schwarz-Baum ist ein annähernd ausgewogener binärer Suchbaum, der rote und schwarze Knoten enthält und sicherstellt, dass der Höhenunterschied zwischen dem linken und rechten Teilbaum eines beliebigen Knotens weniger als das Zweifache beträgt.</p><p><img src=https://image.pseudoyu.com/images/red_black_tree_2.png alt=red_black_tree_2></p><h4 id=eigenschaften>Eigenschaften</h4><p>Er muss die folgenden fünf Eigenschaften erfüllen:</p><ol><li>Knoten sind entweder rot oder schwarz</li><li>Der Wurzelknoten ist schwarz</li><li>Blattknoten (NIL) sind schwarz</li><li>Beide Kinder jedes roten Knotens sind schwarz</li><li>Jeder Pfad von einem gegebenen Knoten zu einem seiner Nachkommen-NIL-Knoten enthält die gleiche Anzahl schwarzer Knoten</li></ol><p>Rot-Schwarz-Bäume sind nicht perfekt ausgewogen, aber die Anzahl der Schichten in den linken und rechten Teilbäumen ist gleich, daher auch als schwarz perfekt ausgewogen bekannt. Da er annähernd ausgewogen ist, wird die Häufigkeit von Rotationen reduziert, die Wartungskosten sinken und die Zeitkomplexität bleibt bei LogN.</p><h4 id=operationen>Operationen</h4><p>Rot-Schwarz-Bäume erhalten ihre Selbstbalance hauptsächlich durch drei Operationen:</p><ul><li>Linksrotation</li><li>Rechtsrotation</li><li>Farbänderung</li></ul><h4 id=vergleich-mit-avl-bäumen>Vergleich mit AVL-Bäumen</h4><ul><li>AVL-Bäume bieten schnellere Suchanfragen (aufgrund perfekter Balance)</li><li>Rot-Schwarz-Bäume bieten schnellere Einfüge- und Löschoperationen</li><li>AVL-Bäume speichern mehr Knoteninformationen (Balancefaktor und Höhe) und belegen daher mehr Speicherplatz</li><li>AVL-Bäume eignen sich besser, wenn Leseoperationen häufig und Schreiboperationen selten sind, oft in Datenbanken verwendet; Rot-Schwarz-Bäume werden im Allgemeinen verwendet, wenn Schreiboperationen häufiger sind, da sie prägnant und leicht zu implementieren sind, oft in Bibliotheken verschiedener Hochsprachen verwendet, wie map, set usw.</li></ul><h4 id=code-implementierung>Code-Implementierung</h4><p>Da Rot-Schwarz-Bäume relativ komplex sind, wurde der Implementierungscode zum Lernen und als Referenz auf GitHub hochgeladen.</p><p><a href=https://github.com/pseudoyu/RedBlackTree-java>pseudoyu/RedBlackTree-Java</a></p><h3 id=trie---wörterbaumbaum>Trie - Wörterbaumbaum</h3><p>Trie, auch bekannt als Wörterbaumbaum, Präfixbaum oder Schlüsselbaum, wird häufig für Statistiken und Sortierung großer Mengen von Zeichenketten verwendet, wie z.B. Textdiskstatistiken in Suchmaschinen.</p><p>Er kann unnötige Zeichenkettenvergleiche minimieren, was zu einer hohen Abfrageeffizienz führt.</p><p><img src=https://image.pseudoyu.com/images/trie_structure.png alt=trie_structure></p><h4 id=eigenschaften-1>Eigenschaften</h4><ol><li>Knoten speichern keine vollständigen Wörter</li><li>Die einem Knoten entsprechende Zeichenkette wird durch Verbinden der Zeichen gebildet, die auf dem Weg vom Wurzelknoten zu diesem Knoten durchlaufen werden</li><li>Die von allen Kindknoten eines Knotens dargestellten Pfadzeichen sind unterschiedlich</li><li>Knoten können zusätzliche Informationen speichern, wie z.B. Worthäufigkeit</li></ol><h4 id=implementierung-interner-knoten>Implementierung interner Knoten</h4><p><img src=https://image.pseudoyu.com/images/trie_nodes.png alt=trie_nodes></p><p>Die Höhe eines Trie ist relativ gering, aber er belegt mehr Speicherplatz. Die Kernidee ist, Speicher gegen Zeit einzutauschen.</p><p>Er verwendet die gemeinsamen Präfixe von Zeichenketten, um die Kosten der Abfragezeit zu reduzieren und so die Effizienz zu verbessern, was natürlich Geschäftsszenarien wie Wortassoziationen lösen kann.</p><h4 id=code-implementierung-1>Code-Implementierung</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Trie</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>Trie</span><span class=o>[]</span> <span class=n>children</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>boolean</span> <span class=n>isEnd</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>Trie</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>children</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Trie</span><span class=o>[</span><span class=n>26</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=n>isEnd</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>insert</span><span class=o>(</span><span class=n>String</span> <span class=n>word</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Trie</span> <span class=n>node</span> <span class=o>=</span> <span class=k>this</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>word</span><span class=o>.</span><span class=na>length</span><span class=o>();</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>char</span> <span class=n>ch</span> <span class=o>=</span> <span class=n>word</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=n>ch</span> <span class=o>-</span> <span class=sc>&#39;a&#39;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>children</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span><span class=o>.</span><span class=na>children</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Trie</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>children</span><span class=o>[</span><span class=n>index</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>.</span><span class=na>isEnd</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>search</span><span class=o>(</span><span class=n>String</span> <span class=n>word</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Trie</span> <span class=n>node</span> <span class=o>=</span> <span class=n>searchPrefix</span><span class=o>(</span><span class=n>word</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>node</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>node</span><span class=o>.</span><span class=na>isEnd</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>startsWith</span><span class=o>(</span><span class=n>String</span> <span class=n>prefix</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>searchPrefix</span><span class=o>(</span><span class=n>prefix</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>Trie</span> <span class=nf>searchPrefix</span><span class=o>(</span><span class=n>String</span> <span class=n>prefix</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Trie</span> <span class=n>node</span> <span class=o>=</span> <span class=k>this</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>prefix</span><span class=o>.</span><span class=na>length</span><span class=o>();</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>char</span> <span class=n>ch</span> <span class=o>=</span> <span class=n>prefix</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=n>ch</span> <span class=o>-</span> <span class=sc>&#39;a&#39;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>children</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=na>children</span><span class=o>[</span><span class=n>index</span><span class=o>];</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>node</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=modifizierte-merkle-patricia-tries>Modifizierte Merkle Patricia Tries</h3><h4 id=speichermethode-für-ethereum-kontostatus>Speichermethode für Ethereum-Kontostatus</h4><ol><li>Die Verwendung einer Key-Value-Hashtabelle für die Speicherung ist kostspielig, da bei jeder Blockerstellung neue Transaktionen in Blöcke gepackt werden, was den Merkle-Baum verändert, aber tatsächlich ändern sich nur wenige Konten.</li><li>Die direkte Verwendung eines Merkle-Baums zur Speicherung von Konten ist nicht praktikabel, da er keine effiziente Methode zum Suchen und Aktualisieren bietet.</li><li>Die Verwendung eines sortierten Merkle-Baums ist ebenfalls nicht praktikabel, da neue Kontoadressen zufällig generiert werden, was Einfügen und Neusortieren erfordert.</li></ol><h4 id=mpt-struktur>MPT-Struktur</h4><p>Nutzung der Eigenschaften der Trie-Struktur:</p><ol><li>Die Trie-Struktur bleibt nach dem Mischen unverändert, ist natürlich sortiert und wird nicht beeinflusst, selbst wenn neue Werte eingefügt werden, was für die kontobasierte Struktur von Ethereum geeignet ist.</li><li>Sie hat eine gute Aktualisierungslokalität, da beim Aktualisieren nicht der gesamte Baum durchlaufen werden muss.</li></ol><p>Die Trie-Struktur verschwendet jedoch Speicherplatz und ist ineffizient, wenn Schlüssel-Wert-Paare spärlich verteilt sind. Ethereum-Kontoadressen sind 40-stellige Hexadezimalzahlen mit etwa 2^160 möglichen Adressen, die extrem spärlich sind (um Hash-Kollisionen zu verhindern).</p><p>Daher muss die Trie-Struktur komprimiert werden, was der Patricia Trie ist. Nach der Komprimierung wird die Höhe des Baums deutlich reduziert, was sowohl den Speicherplatz als auch die Effizienz verbessert.</p><p><img src=https://image.pseudoyu.com/images/pactricia_trie.png alt=pactricia_trie></p><h4 id=modifizierte-mpt-struktur>Modifizierte MPT-Struktur</h4><p>Die von Ethereum tatsächlich verwendete Struktur ist die modifizierte MPT-Struktur, wie unten gezeigt:</p><p><img src=https://image.pseudoyu.com/images/modified_merkle_pactricia_trie.png alt=modified_merkle_pactricia_trie></p><p>Wenn ein neuer Block veröffentlicht wird, ändern sich die Werte der neuen Knoten im Zustandsbaum. Anstatt den ursprünglichen Wert zu ändern, werden neue Zweige erstellt, wodurch der ursprüngliche Zustand erhalten bleibt (und somit ein Rollback ermöglicht wird).</p><p>Im Ethereum-System sind Forks häufig, und Daten in verwaisten Blöcken müssen zurückgesetzt werden. Aufgrund des Vorhandenseins von Smart Contracts in ETH müssen zur Unterstützung des Rollbacks von Smart Contracts frühere Zustände beibehalten werden.</p><h4 id=code-implementierung-2>Code-Implementierung</h4><p>Der Code bezieht sich auf die Java-Implementierung von Ethereum.</p><p><a href=https://github.com/ethereum/ethereumj/tree/develop/ethereumj-core/src/main/java/org/ethereum/trie>ethereum/ethereumj - GitHub</a></p><h2 id=fazit>Fazit</h2><p>Das oben Genannte ist eine Analyse der Datenstrukturen <code>Ethereum MPT</code> und Rot-Schwarz-Baum. Als ich mich mit LeetCode abmühte, dachte ich oft, dass das Lernen dieser Dinge nutzlos sei, aber ich hatte nicht erwartet, so bald ein Anwendungsszenario zu haben. Wir müssen immer noch gut verstehen und üben!</p><h2 id=referenzen>Referenzen</h2><blockquote><ol><li><a href=https://www.jianshu.com/p/e136ec79235c>30 Bilder, die Ihnen helfen, Rot-Schwarz-Bäume gründlich zu verstehen</a></li><li><a href=https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/>LeetCode-Implementierung von Trie</a></li><li><a href=https://github.com/pseudoyu/RedBlackTree-java>pseudoyu/RedBlackTree-Java</a></li><li><a href=https://segmentfault.com/a/1190000016050921>Ethereum-Quellcode-Analyse &ndash; MPT-Baum</a></li><li><a href=https://github.com/ethereum/ethereumj/tree/develop/ethereumj-core/src/main/java/org/ethereum/trie>ethereum/ethereumj</a></li></ol></blockquote></articl><h2>Verwandte Beiträge</h2><dl class=row></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2022-07-01</dt><dd class=col-md-9><a href=/de/2022/07/01/two_phase_commit_contract_practice_in_solidity/>Implementierung von Two-Phase Commit in Solidity Smart Contracts unter Verwendung von State Locks</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2022-06-09</dt><dd class=col-md-9><a href=/de/2022/06/09/learn_solidity_from_scratch_hardhat/>Solidity Smart Contract Entwicklung - Verwendung des Hardhat Frameworks</a></dd></dl></dl><dt class=col-md-3>2022-06-08</dt><dd class=col-md-9><a href=/de/2022/06/08/learn_solidity_from_scratch_ethersjs/>Solidity Smart Contract Entwicklung - Beherrschung von ethers.js</a></dd></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2022-05-30</dt><dd class=col-md-9><a href=/de/2022/05/30/learn_solidity_from_scratch_web3py/>Solidity Smart Contract Entwicklung - Meistern von Web3.py</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2022-05-25</dt><dd class=col-md-9><a href=/de/2022/05/25/learn_solidity_from_scratch_basic/>Solidity Smart Contract Entwicklung - Grundlagen</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><div class=author-card><div class=underline></div><div class=author-box><div class=author-image><a href=https://www.pseudoyu.com><img src=/images/author.webp alt=pseudoyu></a></div><div class=author-content><p class=author-title>Autor</p><p class=author-name>pseudoyu</p><p class=author-desc>Backend- & Smart-Contract-Entwickler, MSc-Absolvent in ECIC (Electronic Commerce and Internet Computing) an der Universität Hongkong (HKU). Lerne und entwickle gerne Neues. <a href=https://github.com/pseudoyu>Folge mir auf GitHub</a></p></div></div></div><div align=center><div class=comment-underline></div></div><br><div class=comments><div class=title><span>Comments</span>
<span class=counter><span class=remark42__counter data-url=https://www.pseudoyu.com/de/2021/08/16/blockchain_ethereum_mpt/></span></span></div><div id=remark42></div></div><script>var remark_config={host:"https://comments.pseudoyu.com",site_id:"pseudoyu.com",components:["embed","counter"],max_shown_comments:20,simple_view:!0,theme:"light"}</script><script>(function(){const t=window.REMARK42;if(t)t.destroy(),t.createInstance(remark_config);else for(const t of remark_config.components){var n=document,e=n.createElement("script");e.src=`${remark_config.host}/web/${t}.mjs`,e.type="module",e.defer=!0,e.setAttribute("data-no-instant",""),n.head.appendChild(e)}})()</script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Sitemap</div><ul class=list-unstyled><li><a href=https://www.pseudoyu.com/de/tags/>Schlagworte</a></li><li><a href=https://www.pseudoyu.com/de/categories/>Kategorien</a></li><li><a rel=alternate type=application/rss+xml href=https://www.pseudoyu.com/de/index.xml><i class="fas fa-rss-square"></i> RSS-Feed</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Social</div><ul class=list-unstyled><li><a href=https://t.me/pseudoyulife rel=noopener target=_blank>Telegram</a></li><li><a href=https://twitter.com/pseudo_yu rel=noopener target=_blank>Twitter</a></li><li><a href=https://www.instagram.com/pseudo.yu/ rel=noopener target=_blank>Instagram</a></li><li><a href=https://space.bilibili.com/5374948/ rel=noopener target=_blank>BiliBili</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Links</div><ul class=list-unstyled><li><a href=https://github.com/pseudoyu rel=noopener target=_blank>Yu's GitHub</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em><a href="https://stats.pseudoyu.com?access-token=2m1u5i2k413q0733h2a3332w3m1t6r634g1m6n" rel=noopener target=_blank>Yu's blog analytics</a></em></small><br><small><em>Powered by <a href=https://gohugo.io rel=noopener target=_blank>Hugo</a> - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>den</a></em></small><br><small><em><a href=https://www.hku.hk rel=noopener target=_blank>The University of Hong Kong</a> - <a href=https://www.cs.hku.hk rel=noopener target=_blank>CS</a></em></small><br><small>&copy;
Yu Zhang
2020 -
2024</small></p></div><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" id=scroll-top class=scroll-top accesskey=g><span class=arrow-icon></span></a>
<script>var mybutton=document.getElementById("scroll-top");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script></body></html>