<!doctype html><html lang=de itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.105.0"><meta charset=utf-8><title>Docker Grundlagen und Praktiken · Pseudoyu</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><script data-goatcounter=https://stats.pseudoyu.com/count async src=//stats.pseudoyu.com/count.js></script><meta name=description content="《后来的我们 - 五月天》 Vorwort Dies ist der erste Artikel im Container-Abschnitt der Arbeitspraxis-Serie, der hauptsächlich die Grundlagen und Praktiken von Docker vorstellt. Als Backend-Entwickler habe ich zu Beginn meiner Karriere hauptsächlich lokal debuggt und hatte noch keine wirklichen"><meta name=keywords content="hugo,blockchain,programming"><link rel=canonical href=https://www.pseudoyu.com/de/2022/09/07/container_docker_basic/><link rel=alternate href=https://www.pseudoyu.com/zh/2022/09/07/container_docker_basic/ hreflang=zh><link rel=alternate href=https://www.pseudoyu.com/en/2022/09/07/container_docker_basic/ hreflang=en><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css integrity=sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css integrity=sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ crossorigin=anonymous><link rel=stylesheet href=https://www.pseudoyu.com/css/den.css><link rel=stylesheet href=https://www.pseudoyu.com/css/custom.css><meta property="og:title" content="Docker Grundlagen und Praktiken"><meta property="og:description" content="《后来的我们 - 五月天》 Vorwort Dies ist der erste Artikel im Container-Abschnitt der Arbeitspraxis-Serie, der hauptsächlich die Grundlagen und Praktiken von Docker vorstellt. Als Backend-Entwickler habe ich zu Beginn meiner Karriere hauptsächlich lokal debuggt und hatte noch keine wirklichen"><meta property="og:type" content="article"><meta property="og:url" content="https://www.pseudoyu.com/de/2022/09/07/container_docker_basic/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-07T01:30:48+08:00"><meta property="article:modified_time" content="2022-09-07T01:30:48+08:00"><meta itemprop=name content="Docker Grundlagen und Praktiken"><meta itemprop=description content="《后来的我们 - 五月天》 Vorwort Dies ist der erste Artikel im Container-Abschnitt der Arbeitspraxis-Serie, der hauptsächlich die Grundlagen und Praktiken von Docker vorstellt. Als Backend-Entwickler habe ich zu Beginn meiner Karriere hauptsächlich lokal debuggt und hatte noch keine wirklichen"><meta itemprop=datePublished content="2022-09-07T01:30:48+08:00"><meta itemprop=dateModified content="2022-09-07T01:30:48+08:00"><meta itemprop=wordCount content="3414"><meta itemprop=keywords content="container,docker,devops,programming,work practice series,work,practice,backend,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker Grundlagen und Praktiken"><meta name=twitter:description content="《后来的我们 - 五月天》 Vorwort Dies ist der erste Artikel im Container-Abschnitt der Arbeitspraxis-Serie, der hauptsächlich die Grundlagen und Praktiken von Docker vorstellt. Als Backend-Entwickler habe ich zu Beginn meiner Karriere hauptsächlich lokal debuggt und hatte noch keine wirklichen"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://www.pseudoyu.com/images/background.webp);background-position:50%;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.pseudoyu.com/de/><img class="mr20 header-logo-image" src=https://image.pseudoyu.com/images/fly.png alt=logo>
Pseudoyu</a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/de/category/ideas/>Ideen</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/de/category/tools/>Tools</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/de/category/develop/>Code</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/de/links/>Links</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/de/search/>Suche</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/de/about/>Über</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/><i class="fas fa-globe"></i> 简</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/><i class="fas fa-globe"></i> EN</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>Docker Grundlagen und Praktiken</h1><p class=header-date>Autor:
pseudoyu
| <span>3414 Wörter, 7 Minuten</span>
| <span class=remark42__counter data-url=https://www.pseudoyu.com/de/2022/09/07/container_docker_basic/></span> Kommentare
| 2022-09-07
| Kategorie:
<a href=https://www.pseudoyu.com/de/category/develop/>Develop</a></p><div class=header-underline></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.pseudoyu.com/de/tag/backend/>backend</a>,
<a href=https://www.pseudoyu.com/de/tag/container/>container</a>,
<a href=https://www.pseudoyu.com/de/tag/devops/>devops</a>,
<a href=https://www.pseudoyu.com/de/tag/docker/>docker</a>,
<a href=https://www.pseudoyu.com/de/tag/practice/>practice</a>,
<a href=https://www.pseudoyu.com/de/tag/programming/>programming</a>,
<a href=https://www.pseudoyu.com/de/tag/work/>work</a>,
<a href=https://www.pseudoyu.com/de/tag/work-practice-series/>work practice series</a></p><div class=clearfix></div><p class="float-right translations"><i class="fas fa-language" aria-hidden=true></i>
Übersetzungen:
<a href=https://www.pseudoyu.com/zh/2022/09/07/container_docker_basic/>ZH</a>, <a href=https://www.pseudoyu.com/en/2022/09/07/container_docker_basic/>EN</a></p></div></div></div></div></div><main><div class="container content"><articl data-pagefind-body><figure><audio controls preload=metadata><source src=/audios/here_after_us.mp3 type=audio/mpeg></audio><i><figcaption>《后来的我们 - 五月天》</figcaption></i></figure><h2 id=vorwort>Vorwort</h2><p>Dies ist der erste Artikel im Container-Abschnitt der Arbeitspraxis-Serie, der hauptsächlich die Grundlagen und Praktiken von Docker vorstellt.</p><p>Als Backend-Entwickler habe ich zu Beginn meiner Karriere hauptsächlich lokal debuggt und hatte noch keine wirklichen Erfahrungen mit der Verwendung von Docker gemacht. Erst später, als ich mich mit komplexeren Entwicklungen im Bereich der zugrunde liegenden Blockchain beschäftigte, stieß ich auf Probleme. Aufgrund der komplizierten Abhängigkeitsbeziehungen von Blockchains oder deren zugehörigen Tools sowie Versionskonflikten wurde es notwendig, jedes Mal komplexe Umgebungen auf lokalen Maschinen oder Servern zu konfigurieren. Darüber hinaus mussten viele Dienste und Konfigurationen nach jedem Neustart neu bereitgestellt werden, was den Prozess umständlich und anfällig für unerklärliche plattformübergreifende Fehler machte.</p><p>Daher begann ich nach und nach, den Ansatz zu verfolgen, projektspezifische Dockerfiles zu schreiben und Images für die anschließende Entwicklung und Fehlersuche zu kompilieren. Bereitstellungsmaschinen mussten nur die Docker-Umgebung (und Docker Compose) installieren, ohne dass verschiedene Abhängigkeiten lokal installiert werden mussten, was sehr praktisch war. Später konfigurierten wir zusammen mit meinem Teamleiter den CI/CD-Prozess des Projekts basierend auf Docker-Images, GitLab CI und der k8s-Umgebung, was die Entwicklungs- und Debugging-Effizienz erheblich verbesserte.</p><p>Dieser Artikel fasst Docker-bezogene Konzepte und Praktiken auf der Grundlage dieser Erfahrungen zusammen und hofft, in gewisser Weise hilfreich zu sein.</p><h2 id=einführung-in-docker>Einführung in Docker</h2><p>Die von uns entwickelten Dienste laufen oft als Binärdateien im Betriebssystem, während Docker eine Container-Technologie ist, die unsere Anwendung und zugehörige Abhängigkeiten in einem Container verpackt. Container basieren in der Regel auf einem leichtgewichtigen Linux-Image und sind ein Stapel mehrerer Bildebenen. Unsere Anwendung befindet sich normalerweise in der obersten Schicht, und diese Abhängigkeitsbeziehungen werden im Dockerfile spezifiziert.</p><p>Die Verwendung von Containern für die Bereitstellung hat viele klare Vorteile gegenüber der Bereitstellung auf lokalen Maschinen oder Remote-Servern.</p><ol><li><p>Keine Notwendigkeit, verschiedene Umgebungen und Abhängigkeiten im Betriebssystem zu installieren (außer Docker selbst). Wenn wir den ursprünglichen Dienststartmodus übernehmen würden, würde der Entwicklungsprozess sehr umständlich werden und ständige Kommunikation zwischen Entwicklern und Betrieb erfordern, um die Umgebungskonfiguration und Bereitstellung abzuschließen. Darüber hinaus ist es sehr leicht, Abhängigkeits-/Versionskonflikte zu verursachen, wenn mehrere Dienste auf einer Maschine bereitgestellt werden.</p></li><li><p>Kann unabhängige Bereitstellungsumgebungen haben. Wir erstellen Images, indem wir Dockerfiles für verschiedene Projekte schreiben und die für die Anwendung erforderliche Umgebung und Abhängigkeiten im Image verpacken. Dies macht es bequem, verschiedene Versionen derselben Anwendung auszuführen oder mehrere Instanzen gemeinsamer Dienste wie MySQL auszuführen. Diese können über Docker-Befehle oder Docker Compose-Befehle verwaltet werden, was einen Start/Pause mit einem Klick ermöglicht.</p></li><li><p>Docker ist nicht stark von der Version des Betriebssystems selbst abhängig. Dasselbe Docker-Image kann auf verschiedenen Betriebssystemen (Windows, macOS, verschiedene Linux-Distributionen) ausgeführt werden, was die Dienstefreigabe, Migration und plattformübergreifende Bereitstellung erleichtert.</p></li><li><p>Im Vergleich zu virtuellen Maschinen haben Docker-Container keinen Kernel und enthalten nur die Anwendungsschicht, was sie kleiner in der Größe, schneller beim Start und leichtgewichtiger macht.</p></li></ol><p>Natürlich ist die Kompatibilität von Docker-Containern im Vergleich zu Betriebssystemen und virtuellen Maschinen relativ schlechter. Zum Beispiel können VMs jedes andere Betriebssystem ausführen und spezifischere Bedürfnisse erfüllen.</p><h2 id=grundlegende-docker-operationen>Grundlegende Docker-Operationen</h2><h3 id=installation-von-docker>Installation von Docker</h3><p>Die Installation von Docker ist einfach. Laden Sie das Installationspaket für Ihr Betriebssystem von der <a href=https://www.docker.com>offiziellen Website</a> herunter und folgen Sie den Anweisungen zur Installation.</p><h4 id=macos>macOS</h4><p>Für mein persönliches macOS-System habe ich zunächst <a href=https://www.docker.com/products/docker-desktop/>Docker Desktop</a> installiert, das die Verwaltung von Images und Containern über eine grafische Benutzeroberfläche ermöglicht. Es ist praktisch, verbraucht aber mehr Ressourcen und ist energieintensiv.</p><p>Später habe ich <a href=https://github.com/abiosoft/colima>Colima</a> ausprobiert, eine relativ leichtgewichtige Container-Laufzeitumgebung. Es ist sehr praktisch für lokales Debugging auf macOS-Systemen. Ich empfehle, es zu verwenden. Sie können die Umgebung gemäß der offiziellen Dokumentation des Projekts installieren und konfigurieren. Ich habe es direkt mit dem <code>brew</code> Paketmanagement-Tool installiert:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>brew install colima
</span></span></code></pre></div><p>Nach der Installation führen Sie <code>colima start</code> aus, um den Container zu starten, und <code>colima stop</code>, um den Container zu stoppen. Weitere Befehle können Sie über <code>colima --help</code> einsehen.</p><p>Ich habe meine übliche Entwicklungsumgebung mit dem folgenden Befehl gestartet, den Sie nach Ihren eigenen Bedürfnissen konfigurieren können:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>colima start -c <span class=m>8</span> -m <span class=m>16</span> -a x86_64 -p docker-amd
</span></span></code></pre></div><h4 id=centos>CentOS</h4><p>Im Vergleich zur lokalen Entwicklung wird Docker häufiger für die Bereitstellung von Anwendungen auf Servern verwendet. Mein häufig verwendetes Betriebssystem ist <code>CentOS 7</code>, das über das <code>yum</code> Paketmanagement-Tool installiert werden kann:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>yum install -y yum-utils device-mapper-persistent-data lvm2
</span></span><span class=line><span class=cl>yum-config-manager  --add-repo https://download.docker.com/linux/centos/docker-ce.repo
</span></span><span class=line><span class=cl>yum install docker-ce
</span></span></code></pre></div><p>Nach der Installation starten Sie den Docker-Dienst und konfigurieren ihn so, dass er beim Systemstart automatisch gestartet wird:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>systemctl <span class=nb>enable</span> docker
</span></span><span class=line><span class=cl>systemctl start docker
</span></span></code></pre></div><h3 id=docker-images>Docker Images</h3><p>Docker hat hauptsächlich zwei Konzepte: Images und Container. Ein Image kann als Vorlage für einen Container betrachtet werden, der über ein Dockerfile kompiliert wurde, während ein Container eine Instanz eines Images ist.</p><h4 id=dockerfile>Dockerfile</h4><p>Wir verwenden Dockerfile, um die für die Anwendung erforderliche Umgebung und Abhängigkeiten zu spezifizieren. Das grundlegende Format sieht wie folgt aus:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> &lt;image&gt;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENV</span> <span class=nv>USERNAME</span><span class=o>=</span>admin <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=nv>PASSWORD</span><span class=o>=</span><span class=m>123456</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>RUN</span> mkdir -p &lt;app-directory&gt;<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . /&lt;app-directory&gt;<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;&lt;command&gt;&#34;</span><span class=p>,</span> <span class=s2>&#34;&lt;entrypoint file&gt;&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>Nach Abschluss des Dockerfiles können wir das Image mit dem Befehl <code>docker build</code> im gleichen Verzeichnis erstellen (oder das Dockerfile angeben):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Image erstellen</span>
</span></span><span class=line><span class=cl>docker build -t &lt;image:tag&gt; .
</span></span></code></pre></div><h4 id=speichern-und-laden-von-images>Speichern und Laden von Images</h4><p>Wir können lokal kompilierte Images als <code>tar</code>-Pakete für die Weitergabe speichern:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker save -o &lt;image-name&gt;.tar &lt;image-name&gt;
</span></span></code></pre></div><p>Wenn wir das Image verwenden müssen, können wir das tar-Paket mit dem Befehl <code>docker load</code> laden:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker load -i &lt;image-name&gt;.tar
</span></span></code></pre></div><h4 id=hochladen-und-herunterladen-von-images>Hochladen und Herunterladen von Images</h4><p>Natürlich ist die Weitergabe über Image-<code>tar</code>-Pakete nicht so bequem, und einige Images können sehr groß sein, was die Übertragung erschwert. Daher können wir den Befehl <code>docker push</code> verwenden, um Images in das offizielle Image-Repository oder Unternehmens-/persönliche private Repositories (wie das Projekt, an dem ich arbeite, verwendet Harbor zur Verwaltung von Images) zu übertragen, und den Befehl <code>docker pull</code> zum Herunterladen verwenden.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Offizielles Image herunterladen (Kurzform)</span>
</span></span><span class=line><span class=cl>docker pull &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Offizielles Image herunterladen (vollständiger Befehl)</span>
</span></span><span class=line><span class=cl>docker pull docker.io/library/&lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Image in offizielles Image-Repository Docker Hub hochladen</span>
</span></span><span class=line><span class=cl>docker push &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Image in privates Repository hochladen (Authentifizierung erforderlich)</span>
</span></span><span class=line><span class=cl>docker tag &lt;image:tag&gt; &lt;private-repo-path&gt;/&lt;image:tag&gt;
</span></span><span class=line><span class=cl>docker push &lt;private-repo-path&gt;/&lt;image:tag&gt;
</span></span></code></pre></div><h4 id=docker-image-operationen>Docker Image-Operationen</h4><p>Für Docker-Images sind die Operationen, die ich häufig verwende, das Anzeigen, Löschen und Umbenennen von Tags. Weitere Befehle können Sie über <code>docker image --help</code> oder auf der offiziellen Website einsehen.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Alle Images anzeigen</span>
</span></span><span class=line><span class=cl>docker images
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Image löschen</span>
</span></span><span class=line><span class=cl>docker rmi &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Image umbenennen</span>
</span></span><span class=line><span class=cl>docker tag &lt;old-image:tag&gt; &lt;new-image:tag&gt;
</span></span></code></pre></div><h3 id=container-operationen>Container-Operationen</h3><h4 id=anzeigen-von-containern>Anzeigen von Containern</h4><p>Nachdem wir ein Image über Docker- oder Docker Compose-Befehle gestartet haben, können wir den Dienststatus über die folgenden Befehle anzeigen:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Laufende Container anzeigen</span>
</span></span><span class=line><span class=cl>docker ps
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Alle Container anzeigen</span>
</span></span><span class=line><span class=cl>docker ps -a
</span></span></code></pre></div><h4 id=startenstoppen-von-instanzen-aus-images>Starten/Stoppen von Instanzen aus Images</h4><p>Nachdem wir das erforderliche Image über Dockerfile kompiliert haben, können wir eine Image-Instanz über den Befehl <code>docker run</code> starten und einige Konfigurationen im Befehl hinzufügen, um unsere Dienstanforderungen zu erfüllen. Meine üblichen Operationen sind wie folgt:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Container ausführen</span>
</span></span><span class=line><span class=cl>docker run &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Container ausführen und Namen angeben</span>
</span></span><span class=line><span class=cl>docker run --name &lt;server-name&gt; &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Container im Hintergrundmodus ausführen</span>
</span></span><span class=line><span class=cl>docker run -d &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Port-Mapping</span>
</span></span><span class=line><span class=cl>docker run -p6000:6379 &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Umgebungsvariablen konfigurieren</span>
</span></span><span class=line><span class=cl>docker run -e <span class=nv>USERNAME</span><span class=o>=</span>admin -e <span class=nv>PASSWORD</span><span class=o>=</span><span class=m>123456</span> &lt;image:tag&gt;
</span></span></code></pre></div><h4 id=startenstoppen-von-container-diensten>Starten/Stoppen von Container-Diensten</h4><p>Nachdem wir eine Instanz aus einem Image erstellt haben, können wir den Container-Dienst über die folgenden Befehle starten/stoppen:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Container starten/neu starten</span>
</span></span><span class=line><span class=cl>docker start &lt;container-id&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Container anhalten</span>
</span></span><span class=line><span class=cl>docker stop &lt;container-id&gt;
</span></span></code></pre></div><h4 id=anzeigen-von-logs>Anzeigen von Logs</h4><p>Nachdem wir einen Dienst über Docker gestartet haben, müssen wir oft seine Ausführungsprotokolle zur Fehlersuche einsehen. Wir können sie über <code>docker logs</code> anzeigen, mit spezifischen Befehlen wie folgt:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Logs anzeigen</span>
</span></span><span class=line><span class=cl>docker logs &lt;container-id&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Logs im Folgemodus anzeigen</span>
</span></span><span class=line><span class=cl>docker logs -f &lt;container-id&gt;
</span></span></code></pre></div><h4 id=betreten-von-containern>Betreten von Containern</h4><p>Manchmal müssen wir für die Dienstinspektion und Fehlersuche intern in den Docker-Container-Dienst eintreten. Wir können über den Befehl <code>docker exec</code> in den Container eintreten, mit spezifischen Befehlen wie folgt:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Bestimmten Container nach ID betreten</span>
</span></span><span class=line><span class=cl>docker <span class=nb>exec</span> -it &lt;container-id&gt; &lt;command&gt;
</span></span></code></pre></div><h4 id=docker-netzwerk>Docker-Netzwerk</h4><p>Docker-Container-Instanzen laufen innerhalb eines Netzwerks. In unseren vorherigen Befehlen haben wir kein Netzwerk angegeben, sodass die Dienste unter dem Standardnetzwerk laufen werden. Wir können Netzwerke über den folgenden Befehl anzeigen:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Alle Netzwerke anzeigen</span>
</span></span><span class=line><span class=cl>docker network ls
</span></span></code></pre></div><p>Wenn wir nicht im Standardnetzwerk laufen möchten, können wir ein benutzerdefiniertes Netzwerk über den folgenden Befehl erstellen:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Benutzerdefiniertes Netzwerk erstellen</span>
</span></span><span class=line><span class=cl>docker network create &lt;network-name&gt;
</span></span></code></pre></div><p>Nachdem wir unser benutzerdefiniertes Netzwerk erstellt haben, können wir das Netzwerk beim Erstellen von Container-Instanzen über den Parameter <code>--network</code> angeben:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run --network &lt;network-name&gt; &lt;image:tag&gt;
</span></span></code></pre></div><h4 id=docker-datenpersistenz>Docker-Datenpersistenz</h4><p>Nach dem Ausführen von Diensten mit Docker-Instanzen werden unsere Daten in den Containern gespeichert. Wenn die Container gelöscht werden, werden auch die Daten gelöscht, was bei einigen Diensten, die längere Zeit laufen müssen, zu Datenverlust führen kann. Daher müssen wir die Daten persistieren. Ich verwende üblicherweise Host-Montage und Container-Montage.</p><p>Wir können die Persistenz erreichen, indem wir ein bestimmtes Verzeichnis der Host-Maschine in ein Verzeichnis innerhalb des Containers einbinden:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Host-Verzeichnis in Container-Verzeichnis einbinden</span>
</span></span><span class=line><span class=cl>docker run -v &lt;host-file-path&gt;:&lt;container-file-path&gt; &lt;image:tag&gt;
</span></span></code></pre></div><p>Wir können auch Container-Montage verwenden und Volumes zur Persistenz nutzen:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Sie können auf das Volume über den Namen verweisen</span>
</span></span><span class=line><span class=cl><span class=c1># Docker generiert automatisch einen Pfad</span>
</span></span><span class=line><span class=cl><span class=c1># Windows: C:\ProgramData\docker\volumes</span>
</span></span><span class=line><span class=cl><span class=c1># Linux: /var/lib/docker/volumes</span>
</span></span><span class=line><span class=cl><span class=c1># macOS: /var/lib/docker/volumes</span>
</span></span><span class=line><span class=cl>docker run -v &lt;volume-name&gt;:&lt;container-file-path&gt; &lt;image:tag&gt;
</span></span></code></pre></div><p>Wenn wir nur einbinden müssen und keine spezifische Dateiverwaltung oder -anzeige benötigen, können wir auch die anonyme Container-Montage verwenden, ohne einen Volume-Namen anzugeben, sondern das automatisch generierte Verzeichnis verwenden:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Docker generiert automatisch einen Pfad</span>
</span></span><span class=line><span class=cl><span class=c1># Windows: C:\ProgramData\docker\volumes</span>
</span></span><span class=line><span class=cl><span class=c1># Linux: /var/lib/docker/volumes</span>
</span></span><span class=line><span class=cl><span class=c1># macOS: /var/lib/docker/volumes</span>
</span></span><span class=line><span class=cl>docker run -v &lt;container-file-path&gt; &lt;image:tag&gt;
</span></span></code></pre></div><h2 id=docker-compose>Docker Compose</h2><p>Docker bietet uns umfangreiche Befehle zur Verwendung, aber die Verwendung von Befehlszeilenoperationen ist nicht einfach zu merken, und wenn eine Anwendung von mehreren Umgebungen/Diensten abhängt, erfordert es das separate Ausführen und Verwalten mehrerer Container, was Unannehmlichkeiten verursacht. Daher können wir das Docker Compose-Tool zur Verwaltung verwenden.</p><p>Docker Compose ist ein Tool zum Definieren und Ausführen von Multi-Container-Docker-Anwendungen, das <code>.yaml</code>-Dateien zur Konfigurationsverwaltung verwendet. In meiner täglichen Arbeit verwende ich Docker Compose am häufigsten und verwende den <code>docker run</code>-Befehl nur zum Starten sehr einfacher Anwendungen, was auch für die einheitliche Verwaltung und nachfolgende Konfigurationsanpassungen praktisch ist.</p><h3 id=installation>Installation</h3><p>Wenn Sie Docker Desktop auf macOS installiert haben, enthält es bereits Docker Compose, das direkt verwendet werden kann. Wenn es sich um ein Linux-System handelt, muss es separat installiert werden. Hier nehme ich <code>CentOS 7</code> als Beispiel:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl -L <span class=s2>&#34;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-</span><span class=k>$(</span>uname -s<span class=k>)</span><span class=s2>-</span><span class=k>$(</span>uname -m<span class=k>)</span><span class=s2>&#34;</span> -o /usr/local/bin/docker-compose
</span></span><span class=line><span class=cl>chmod +x /usr/local/bin/docker-compose
</span></span><span class=line><span class=cl>ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
</span></span></code></pre></div><p>Nach der Installation können Sie den Befehl <code>docker-compose</code> verwenden.</p><h3 id=konfigurationsverwaltung>Konfigurationsverwaltung</h3><p>Die Konfigurationsdatei für Docker Compose ist eine <code>yaml</code>-Datei, deren Grundformat wie folgt aussieht:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;3&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nt>container-1</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    	</span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>&lt;image-name&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span>- <span class=l>&lt;host&gt;:&lt;container&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span>- <span class=l>&lt;host-file-path&gt;:&lt;container-file-path&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span><span class=l>&lt;ENV-KEY&gt;=&lt;ENV-VALUE&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container-2</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    	</span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>&lt;image-name&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span>- <span class=l>&lt;host&gt;:&lt;container&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span>- <span class=l>&lt;volume-name-1&gt;:&lt;container-file-path&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span><span class=l>&lt;ENV-KEY&gt;=&lt;ENV-VALUE&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nt>volume-name-1</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    	</span><span class=nt>driver</span><span class=p>:</span><span class=w> </span><span class=l>local</span><span class=w>
</span></span></span></code></pre></div><p>Die meisten Konfigurationen sind intuitiv, wie Dienstname, Image-Name, Port-Mapping, Dateimontage, Umgebungsvariablen usw.</p><p>Dabei repräsentiert <code>version</code> die Version der Konfigurationsdatei, <code>services</code> die Liste der Dienste und <code>volumes</code> die Liste der eingebundenen Volumes.</p><p>In spezifischen <code>services</code> repräsentiert <code>image</code> den Image-Namen, <code>ports</code> das Port-Mapping, <code>volumes</code> die Dateimontage, <code>environment</code> die Umgebungsvariablen. Weitere Konfigurationen können je nach Projektanforderungen eingesehen werden.</p><h3 id=häufige-befehle>Häufige Befehle</h3><h4 id=startenstoppen-von-diensten>Starten/Stoppen von Diensten</h4><p>Ähnlich wie der Befehl <code>docker run</code> bietet Docker Compose auch die Befehle <code>up</code> und <code>down</code> zum Starten und Stoppen von Diensten.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Dienst starten</span>
</span></span><span class=line><span class=cl>docker-compose -f &lt;name&gt;.yaml up
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Dienst im Hintergrundmodus starten</span>
</span></span><span class=line><span class=cl>docker-compose -f &lt;name&gt;.yaml up -d
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Dienst stoppen</span>
</span></span><span class=line><span class=cl>docker-compose -f &lt;name&gt;.yaml down
</span></span></code></pre></div><h4 id=anzeigen-von-logs-1>Anzeigen von Logs</h4><p>Wir können Dienstprotokolle über den Befehl <code>logs</code> anzeigen.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Logs anzeigen</span>
</span></span><span class=line><span class=cl>docker-compose logs &lt;container-id&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Logs im Folgemodus anzeigen</span>
</span></span><span class=line><span class=cl>docker-compose logs -f &lt;container-id&gt;
</span></span></code></pre></div><h2 id=praktische-betriebsbefehle>Praktische Betriebsbefehle</h2><p>Zusätzlich zu den oben genannten grundlegenden Befehlen verwende ich oft die folgenden häufigen Befehle.</p><h3 id=bereinigung-nicht-verwendeter-container>Bereinigung nicht verwendeter Container</h3><p>Wenn unsere Container-Instanzen aufgrund von Konfigurations- oder Programmlaufzeitfehlern beendet werden, werden sie weiterhin beibehalten. Wir können sie über den Befehl <code>docker ps -a</code> anzeigen. Wir können sie über den folgenden kombinierten Befehl bereinigen:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker rm <span class=sb>`</span>docker ps -a <span class=p>|</span> grep Exited <span class=p>|</span> awk <span class=s1>&#39;{print $1}&#39;</span><span class=sb>`</span>
</span></span></code></pre></div><h3 id=massenimport-lokaler-images>Massenimport lokaler Images</h3><p>Wenn wir eine große Anzahl lokaler Images in eine Maschine importieren müssen, wäre es sehr umständlich, sie einzeln zu importieren. Wir können die Images in dasselbe Verzeichnis legen und den folgenden Befehl für den Massenimport verwenden:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=k>for</span> i in <span class=sb>`</span>ls<span class=sb>`</span><span class=p>;</span> <span class=k>do</span> docker load &lt; <span class=nv>$i</span> <span class=p>;</span> <span class=k>done</span>
</span></span></code></pre></div><h2 id=fazit>Fazit</h2><p>Das oben Genannte ist meine Erklärung der Grundlagen und praktischen Operationen der Docker-Container-Technologie. Ich hoffe, es ist für Sie hilfreich. Tatsächlich gibt es noch viel mehr Inhalt über Docker. Zum Beispiel haben wir im vorherigen Projekt versucht, Dockers <code>Buildkit</code>-Funktion zu verwenden, die die Größe des endgültig erstellten Images drastisch reduzierte, und <code>buildx</code> verwendet, um plattformübergreifende Kompatibilität zu erreichen, usw. Dieser Artikel zielt darauf ab, Grundkenntnisse und häufig verwendete Befehle in der Praxis zu erklären. Wenn Sie an diesen erweiterten Teilen interessiert sind, werde ich sie später aktualisieren.</p><h2 id=referenzen>Referenzen</h2><blockquote><ol><li><a href=https://www.docker.com>Docker Offizielle Website</a></li><li><a href="https://www.youtube.com/watch?v=3c-iBn73dDE">Docker Tutorial für Anfänger</a></li></ol></blockquote></articl><h2>Verwandte Beiträge</h2><dl class=row></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2024-08-05</dt><dd class=col-md-9><a href=/de/2024/08/05/weekly_review_20240805/>Wochenrückblick #67 - Neugestaltung meines Informationseingabesystems mit Follow</a></dd></dl></dl></dl><dt class=col-md-3>2024-07-30</dt><dd class=col-md-9><a href=/de/2024/07/30/weekly_review_20240730/>Wochenrückblick #66 - 10x-Ingenieure, technische Leidenschaft und persönliche Werkzeuge</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2022-09-05</dt><dd class=col-md-9><a href=/de/2022/09/05/database_postgres_basic/>PostgreSQL Grundlagen und Praxis</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2021-03-29</dt><dd class=col-md-9><a href=/de/2021/03/29/database_mysql_basic/>MySQL-Grundlagen und Praxis</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><div class=author-card><div class=underline></div><div class=author-box><div class=author-image><a href=https://www.pseudoyu.com><img src=/images/author.webp alt=pseudoyu></a></div><div class=author-content><p class=author-title>Autor</p><p class=author-name>pseudoyu</p><p class=author-desc>Backend- & Smart-Contract-Entwickler, MSc-Absolvent in ECIC (Electronic Commerce and Internet Computing) an der Universität Hongkong (HKU). Lerne und entwickle gerne Neues. <a href=https://github.com/pseudoyu>Folge mir auf GitHub</a></p></div></div></div><div align=center><div class=comment-underline></div></div><br><div class=comments><div class=title><span>Comments</span>
<span class=counter><span class=remark42__counter data-url=https://www.pseudoyu.com/de/2022/09/07/container_docker_basic/></span></span></div><div id=remark42></div></div><script>var remark_config={host:"https://comments.pseudoyu.com",site_id:"pseudoyu.com",components:["embed","counter"],max_shown_comments:20,simple_view:!0,theme:"light"}</script><script>(function(){const t=window.REMARK42;if(t)t.destroy(),t.createInstance(remark_config);else for(const t of remark_config.components){var n=document,e=n.createElement("script");e.src=`${remark_config.host}/web/${t}.mjs`,e.type="module",e.defer=!0,e.setAttribute("data-no-instant",""),n.head.appendChild(e)}})()</script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Sitemap</div><ul class=list-unstyled><li><a href=https://www.pseudoyu.com/de/tags/>Schlagworte</a></li><li><a href=https://www.pseudoyu.com/de/categories/>Kategorien</a></li><li><a rel=alternate type=application/rss+xml href=https://www.pseudoyu.com/de/index.xml><i class="fas fa-rss-square"></i> RSS-Feed</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Social</div><ul class=list-unstyled><li><a href=https://t.me/pseudoyulife rel=noopener target=_blank>Telegram</a></li><li><a href=https://twitter.com/pseudo_yu rel=noopener target=_blank>Twitter</a></li><li><a href=https://www.instagram.com/pseudo.yu/ rel=noopener target=_blank>Instagram</a></li><li><a href=https://space.bilibili.com/5374948/ rel=noopener target=_blank>BiliBili</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>Links</div><ul class=list-unstyled><li><a href=https://github.com/pseudoyu rel=noopener target=_blank>Yu's GitHub</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em><a href="https://stats.pseudoyu.com?access-token=2m1u5i2k413q0733h2a3332w3m1t6r634g1m6n" rel=noopener target=_blank>Yu's blog analytics</a></em></small><br><small><em>Powered by <a href=https://gohugo.io rel=noopener target=_blank>Hugo</a> - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>den</a></em></small><br><small><em><a href=https://www.hku.hk rel=noopener target=_blank>The University of Hong Kong</a> - <a href=https://www.cs.hku.hk rel=noopener target=_blank>CS</a></em></small><br><small>&copy;
Yu Zhang
2020 -
2024</small></p></div><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" id=scroll-top class=scroll-top accesskey=g><span class=arrow-icon></span></a>
<script>var mybutton=document.getElementById("scroll-top");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script></body></html>