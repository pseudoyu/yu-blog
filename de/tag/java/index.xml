<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on Pseudoyu</title><link>https://www.pseudoyu.com/de/tag/java/</link><description>Recent content in java on Pseudoyu</description><generator>Hugo -- gohugo.io</generator><language>de</language><lastBuildDate>Fri, 01 Jan 2021 00:12:17 +0800</lastBuildDate><atom:link href="https://www.pseudoyu.com/de/tag/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Häufig verwendete Datenstrukturen für LeetCode-Problemlösung (Java-Edition)</title><link>https://www.pseudoyu.com/de/2021/01/01/algorithm_data_structure_java/</link><pubDate>Fri, 01 Jan 2021 00:12:17 +0800</pubDate><guid>https://www.pseudoyu.com/de/2021/01/01/algorithm_data_structure_java/</guid><description>Vorwort Kürzlich habe ich begonnen, Algorithmusprobleme auf LeetCode zu lösen. Bei der berufsbezogenen Algorithmuspraxis liegt der Schwerpunkt auf der Verfeinerung von Problemlösungsansätzen und Programmierfähigkeiten, anstatt komplexe Datenstrukturen wie in Algorithmuswettbewerben zu verwenden. Daher sind die häufig verwendeten Datenstrukturen und Operationen nicht zahlreich. Der versierte Umgang mit diesen kann die Codequalität erheblich verbessern. Ich habe diese Zusammenfassung für eine einfache Referenz erstellt.
Datenstrukturen Array [] Initialisierung // Initialisiere ein Array der Größe 10 mit Standardwert 0 int[] nums = new int[10]; // Initialisiere ein 2D-Boolean-Array boolean[][] visited = new boolean[5][10]; Gängige Methoden // Im Allgemeinen wird zu Beginn einer Funktion eine Nicht-Leer-Prüfung durchgeführt, dann werden Elemente über den Index zugegriffen if (nums.</description></item></channel></rss>