<!doctype html><html lang=zh itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.105.0"><meta charset=utf-8><title>[译] 理解并用 Go 语言实现一个 HTTP 中间件 · Pseudoyu</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><script data-goatcounter=https://stats.pseudoyu.com/count async src=//stats.pseudoyu.com/count.js></script><meta name=description content="简介 当运行在不同计算机上的客户端与服务器进行通信时，就需要使用中间件。通过本文，读者将会了解什么是中间件、中间件使用场景以及它们是如何在 Go 语"><meta name=keywords content="hugo,blockchain,programming"><link rel=canonical href=https://www.pseudoyu.com/zh/2022/02/15/building_middlewares_with_golang/><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css integrity=sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css integrity=sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ crossorigin=anonymous><link rel=stylesheet href=https://www.pseudoyu.com/css/den.css><link rel=stylesheet href=https://www.pseudoyu.com/css/custom.css><meta property="og:title" content="[译] 理解并用 Go 语言实现一个 HTTP 中间件"><meta property="og:description" content="简介 当运行在不同计算机上的客户端与服务器进行通信时，就需要使用中间件。通过本文，读者将会了解什么是中间件、中间件使用场景以及它们是如何在 Go 语"><meta property="og:type" content="article"><meta property="og:url" content="https://www.pseudoyu.com/zh/2022/02/15/building_middlewares_with_golang/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-15T18:24:01+08:00"><meta property="article:modified_time" content="2022-02-15T18:24:01+08:00"><meta itemprop=name content="[译] 理解并用 Go 语言实现一个 HTTP 中间件"><meta itemprop=description content="简介 当运行在不同计算机上的客户端与服务器进行通信时，就需要使用中间件。通过本文，读者将会了解什么是中间件、中间件使用场景以及它们是如何在 Go 语"><meta itemprop=datePublished content="2022-02-15T18:24:01+08:00"><meta itemprop=dateModified content="2022-02-15T18:24:01+08:00"><meta itemprop=wordCount content="1833"><meta itemprop=keywords content="go,middleware,programming,translation,"><meta name=twitter:card content="summary"><meta name=twitter:title content="[译] 理解并用 Go 语言实现一个 HTTP 中间件"><meta name=twitter:description content="简介 当运行在不同计算机上的客户端与服务器进行通信时，就需要使用中间件。通过本文，读者将会了解什么是中间件、中间件使用场景以及它们是如何在 Go 语"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://www.pseudoyu.com/images/background.png);background-position:50%;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.pseudoyu.com/zh/><img class="mr20 header-logo-image" src=https://www.pseudoyu.com/images/icon.png alt=logo>
Pseudoyu</a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/category/ideas/>思考</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/category/tools/>工具</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/category/develop/>编程</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/links/>友链</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/about/>关于</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/search/>搜索</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/><i class="fas fa-globe"></i> EN</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/de/><i class="fas fa-globe"></i> DE</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>[译] 理解并用 Go 语言实现一个 HTTP 中间件</h1><p class=header-date>作者:
pseudoyu
| <span>1833 字, 4 分钟</span>
| <span class=remark42__counter data-url=https://www.pseudoyu.com/zh/2022/02/15/building_middlewares_with_golang/></span> 评论
| 2022-02-15
| 分类:
<a href=https://www.pseudoyu.com/zh/category/develop/>Develop</a></p><div class=header-underline></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.pseudoyu.com/zh/tag/go/>go</a>,
<a href=https://www.pseudoyu.com/zh/tag/middleware/>middleware</a>,
<a href=https://www.pseudoyu.com/zh/tag/programming/>programming</a>,
<a href=https://www.pseudoyu.com/zh/tag/translation/>translation</a></p></div></div></div></div></div><main><div class="container content"><articl data-pagefind-body><h2 id=简介>简介</h2><p>当运行在不同计算机上的客户端与服务器进行通信时，就需要使用中间件。通过本文，读者将会了解什么是中间件、中间件使用场景以及它们是如何在 Go 语言中构建的。</p><h3 id=什么是-http-中间件>什么是 HTTP 中间件</h3><p>为了更好理解 HTTP 中间件是什么，先要解释一些基本概念。假如一个开发者想要建立两台计算机之间的通信（其中一台计算机为另一台提供资源或服务），他将会构建一个 client/server 系统来实现。服务器等待客户端请求资源或服务，并将请求的资源转发给客户端作为响应。请求的资源或服务可能为：</p><ul><li>客户端身份校验</li><li>确认客户端对服务器提供的特定服务是否有访问权限</li><li>提供服务</li><li>保障数据安全，确保客户端无法访问未授权数据，防止数据被窃取</li></ul><p>服务器分为无状态和有状态两类，无状态服务器不关心客户端通信状态，而有状态服务器则关心。</p><p>中间件是一种将软件或企业应用连接到另一个软件应用，并构成分布式系统的软件实体。HTTP 请求被发送到 API 服务器，而服务器向客户端返回 HTTP 响应。</p><p>中间件具备接收请求功能，可以在请求到达处理方法之前对其进行预处理。然后，它将处理具体方法，并将其响应结果发送给客户端。</p><h2 id=中间件使用场景>中间件使用场景</h2><p>最常见的使用场景为：</p><ul><li>日志记录器，用于记录每个 REST API 访问请求</li><li>验证用户 session，并保持通信存活</li><li>用户鉴权</li><li>编写自定义逻辑以抽取请求数据</li><li>为客户端提供服务时将属性附在响应信息</li></ul><h2 id=中间件-handlers>中间件 Handlers</h2><p>在 Go 语言中，中间件 Handler 是封装另一个 <code>http.Handler</code> 以对请求进行预处理或后续处理的 <code>http.Handler</code>。它介于 Go Web 服务器与实际的处理程序之间，因此被称为“中间件”。</p><p><img src=https://image.pseudoyu.com/images/go_middleware_handlers.png alt=go_middleware_handlers></p><p>下面是一个基本的中间件 Handler：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;net/http&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>middleware</span><span class=p>(</span><span class=nx>handler</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=k>return</span> <span class=nx>http</span><span class=p>.</span><span class=nf>HandlerFunc</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Executing middleware before request phase!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=c1>// 将控制权交回 Handler
</span></span></span><span class=line><span class=cl><span class=c1></span>         <span class=nx>handler</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Executing middleware after response phase!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>})</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=kd>func</span> <span class=nf>mainLogic</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=c1>// 业务逻辑
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Executing mainHandler...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;OK&#34;</span><span class=p>))</span> <span class=p>}</span> <span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=c1>// HandlerFunc 返回 HTTP Handler
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=nx>mainLogicHandler</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>HandlerFunc</span><span class=p>(</span><span class=nx>mainLogic</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=nx>http</span><span class=p>.</span><span class=nf>Handle</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>,</span> <span class=nf>middleware</span><span class=p>(</span><span class=nx>mainLogicHandler</span><span class=p>))</span>
</span></span><span class=line><span class=cl>     <span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:8000&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在终端运行代码，得到以下输出结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go run middleware.go
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Executing middleware before request phase!
</span></span><span class=line><span class=cl>Executing mainHandler...
</span></span><span class=line><span class=cl>Executing middleware after response phase!
</span></span></code></pre></div><h3 id=日志中间件-handler>日志中间件 Handler</h3><p>为了更好讲解日志中间件 Handler 是如何工作的，我们将实际构建一个并执行一些方法。以下示例创建了两个中间件 Handler：<code>middlewareGreetingsHandler</code> 和 <code>middlewareTimeHandler</code>。Gorilla Mux 路由的 <code>HandleFunc()</code> 方法用于处理中间件方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;net/http&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>middlewareGreetingsHandler</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;Happy New Year, 2022!&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>middlewareTimeHandler</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>curTime</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Format</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Kitchen</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;the current time is %v&#34;</span><span class=p>,</span> <span class=nx>curTime</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>addr</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;ADDR&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>mux</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>NewServeMux</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>mux</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/v1/greetings&#34;</span><span class=p>,</span> <span class=nx>middlewareHelloHandler</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>mux</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/v1/time&#34;</span><span class=p>,</span> <span class=nx>middlewareTimeHandler</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;server is listening at %s&#34;</span><span class=p>,</span> <span class=nx>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=nx>addr</span><span class=p>,</span> <span class=nx>mux</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>先设置 ADDR 环境变量为空闲端口，并执行 <code>go run main.go</code> 命令来运行服务：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>ADDR</span><span class=o>=</span>localhost:8080
</span></span><span class=line><span class=cl>go run main.go
</span></span></code></pre></div><p>服务运行成功后，在浏览器中访问 <code>localhost:8080/v1/greetings</code> 查看 <code>middlewareGreetingsHandler</code> 的响应信息，访问 <code>localhost:8080/v1/time</code> 查看 <code>middlewareTimeHandler</code> 的响应信息。完成后，我们需要创建日志中间件来记录所有服务访问请求信息，列举请求方法、资源路径以及处理时间。首先我们要初始化一个新的结构体来实现 <code>http.Handler</code> 接口的 <code>ServeHTTP()</code> 方法。这个结构体将会有一个字段来追溯进程调用中的 <code>http.Handler</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 创建一个名为 Logger 的请求日志中间件 Handler 结构体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Logger</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>handler</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ServeHTTP 将请求传递给真正的 Handler 并记录请求细节
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>Logger</span><span class=p>)</span> <span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>start</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span><span class=p>.</span><span class=nx>handler</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s %s %v&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>Method</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>URL</span><span class=p>.</span><span class=nx>Path</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>start</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// NewLogger 构造了一个新的日志中间件 Handler
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>NewLogger</span><span class=p>(</span><span class=nx>handlerToWrap</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=o>*</span><span class=nx>Logger</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>Logger</span><span class=p>{</span><span class=nx>handlerToWrap</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>NewLogger()</code> 接收 <code>http.Handler</code>，并返回一个新的封装后的 <code>Logger</code> 实例。由于 <code>http.ServeMux</code> 满足 <code>http.Handler</code> 接口，可以使用日志中间件封装整个 mux。除此之外，由于 <code>Logger</code> 实现了 <code>ServeHTTP()</code> 方法并满足 <code>http.Handler</code> 接口，它也可以被传递至 <code>http.ListenAndServe()</code> 方法而非封装 mux。最后，修改 <code>main()</code> 方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>addr</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;ADDR&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>mux</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>NewServeMux</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>mux</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/v1/greetings&#34;</span><span class=p>,</span> <span class=nx>middlewareGreetingsHandler</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>mux</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/v1/time&#34;</span><span class=p>,</span> <span class=nx>middlewareTimeHandler</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 使用日志中间件封装 mux
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>wrappedMux</span> <span class=o>:=</span> <span class=nf>NewLogger</span><span class=p>(</span><span class=nx>mux</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;server is listening at %s&#34;</span><span class=p>,</span> <span class=nx>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 使用 wrappedMux 而不是 mux 作为根 handler
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=nx>addr</span><span class=p>,</span> <span class=nx>wrappedMux</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>重新启动服务并请求 API，不论请求路径是什么，所有的请求日志都会展示在终端。</p><h2 id=使用-gorillas-handlers-中间件进行日志记录>使用 Gorilla&rsquo;s <code>Handlers</code> 中间件进行日志记录</h2><p>Gorilla Mux 路由有一个 <code>Handlers</code> 包，为常见任务提供各种中间件，包括：</p><ul><li><code>LoggingHandler</code>：以 Apache 通用日志格式进行记录</li><li><code>CompressionHandler</code>：压缩响应信息</li><li><code>RecoveryHandler</code>: 从 panic 错误中恢复</li></ul><p>在以下示例中，我们使用 <code>LoggingHandler</code> 来实现 API 日志记录。首先，使用 <code>go get</code> 命令安装包：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go get <span class=s2>&#34;github.com/gorilla/handlers&#34;</span>
</span></span></code></pre></div><p>导入包，并在 <code>loggingMiddleware.go</code> 程序中使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/gorilla/handlers&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/gorilla/mux&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;net/http&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>mainLogic</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Processing request!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;OK&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>     <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Finished processing request&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=nx>r</span> <span class=o>:=</span> <span class=nx>mux</span><span class=p>.</span><span class=nf>NewRouter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>     <span class=nx>r</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>,</span> <span class=nx>mainLogic</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=nx>loggedRouter</span> <span class=o>:=</span> <span class=nx>handlers</span><span class=p>.</span><span class=nf>LoggingHandler</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Stdout</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:8080&#34;</span><span class=p>,</span> <span class=nx>loggedRouter</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>运行服务：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go run loggingMiddleware.go
</span></span></code></pre></div><p>在浏览器中访问 <code>localhost:8080</code>，会显示以下输出结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>2022/01/05 10:51:44 Processing request!
</span></span><span class=line><span class=cl>2022/01/01 10:51:44 Finished processing request
</span></span><span class=line><span class=cl>127.0.0.1 - - <span class=o>[</span>05/January/2022:10:51:44 +0530<span class=o>]</span> <span class=s2>&#34;GET / HTTP/1.1&#34;</span>
</span></span><span class=line><span class=cl><span class=m>200</span> <span class=m>2</span> 127.0.0.1 - - <span class=o>[</span>05/January/2017:10:51:44 +0530<span class=o>]</span> <span class=s2>&#34;GET /favicon.ico HTTP/1.1&#34;</span> <span class=m>404</span> <span class=m>19</span>
</span></span></code></pre></div><p>本示例仅介绍了 Gorilla Mux <code>Handlers</code> 包的用法。</p><h2 id=总结>总结</h2><p>本文向读者介绍了什么是中间件。为了便于理解，从零开始构建了一个日志中间件程序，并通过 API 实现了一个使用场景。此外，还介绍并实践了一种在 Go 程序中构造中间件更简单的解决方案（即使用 Gorilla Mux Handler）。在未来的文章中，我将讲解如何在 Go 中构建 RPC 服务与客户端。</p><h2 id=文章信息>文章信息</h2><blockquote><ol><li><a href=https://ghostmac.hashnode.dev/understanding-and-crafting-http-middlewares-in-go>原文地址</a></li><li><a href=https://ghostmac.hashnode.dev>原文作者：MacBobby Chibuzor</a></li><li><a href=https://github.com/gocn/translator/blob/master/2022/w07_building_middlewares_with_golang.md>本文永久链接</a></li><li><a href=https://github.com/gocn/translator>GoCN &lt;每周译 Go></a></li><li><a href=https://github.com/pseudoyu>译者：张宇</a></li><li><a href=https://github.com/xkkhy>校对：小超人</a></li></ol></blockquote></articl><h2>相关文章</h2><dl class=row></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2023-01-12</dt><dd class=col-md-9><a href=/zh/2023/01/12/golang_120_language_changes/>[译] Go 1.20 新变化！第一部分：语言特性</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2022-12-08</dt><dd class=col-md-9><a href=/zh/2022/12/08/go_style_guide/>[译] Google Go 风格指南</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2022-09-10</dt><dd class=col-md-9><a href=/zh/2022/09/10/vulnerability_management_for_go/>[译] Go 新漏洞管理工具：govulncheck</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2022-06-06</dt><dd class=col-md-9><a href=/zh/2022/06/06/golang_creators_look_back/>[译] 是什么让 Golang 如此受欢迎？语言创造者的回顾</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2022-05-21</dt><dd class=col-md-9><a href=/zh/2022/05/21/writing_a_simple_in_memory_key_value_database_in_go/>[译] 用 Go 编写一个简单的内存键值数据库</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><div class=author-card><div class=underline></div><div class=author-box><div class=author-image><a href=https://www.pseudoyu.com><img src=/images/author.webp alt=pseudoyu></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>pseudoyu</p><p class=author-desc>后端 & 智能合约研发工程师，HKU ECICer。喜欢探索新技术，空闲时也折腾博客搭建、效率工具等。 在 <a href=https://github.com/pseudoyu>GitHub</a> 关注我。在我的 <a href=https://t.me/pseudoyulife>Telegram 频道</a>了解更多。</p></div></div></div><div align=center><div class=comment-underline></div></div><br><div class=comments><div class=title><span>Comments</span>
<span class=counter><span class=remark42__counter data-url=https://www.pseudoyu.com/zh/2022/02/15/building_middlewares_with_golang/></span></span></div><div id=remark42></div></div><script>var remark_config={host:"https://comments.pseudoyu.com",site_id:"pseudoyu.com",components:["embed","counter"],max_shown_comments:20,simple_view:!0,theme:"light"}</script><script>(function(){const t=window.REMARK42;if(t)t.destroy(),t.createInstance(remark_config);else for(const t of remark_config.components){var n=document,e=n.createElement("script");e.src=`${remark_config.host}/web/${t}.mjs`,e.type="module",e.defer=!0,e.setAttribute("data-no-instant",""),n.head.appendChild(e)}})()</script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://www.pseudoyu.com/zh/tags/>标签</a></li><li><a href=https://www.pseudoyu.com/zh/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://www.pseudoyu.com/zh/index.xml><i class="fas fa-rss-square"></i> RSS</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社交</div><ul class=list-unstyled><li><a href=https://t.me/pseudoyulife rel=noopener target=_blank>Telegram</a></li><li><a href=https://twitter.com/pseudo_yu rel=noopener target=_blank>Twitter</a></li><li><a href=https://www.instagram.com/pseudo.yu/ rel=noopener target=_blank>Instagram</a></li><li><a href=https://space.bilibili.com/5374948/ rel=noopener target=_blank>BiliBili</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>关于</div><ul class=list-unstyled><li><a href=https://github.com/pseudoyu rel=noopener target=_blank>Yu's GitHub</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em><a href="https://stats.pseudoyu.com?access-token=2m1u5i2k413q0733h2a3332w3m1t6r634g1m6n" rel=noopener target=_blank>Yu's blog analytics</a></em></small><br><small><em>Powered by <a href=https://gohugo.io rel=noopener target=_blank>Hugo</a> - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>den</a></em></small><br><small><em><a href=https://www.hku.hk rel=noopener target=_blank>The University of Hong Kong</a> - <a href=https://www.cs.hku.hk rel=noopener target=_blank>CS</a></em></small><br><small>&copy;
Yu Zhang
2020 -
2024</small></p></div><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" id=scroll-top class=scroll-top accesskey=g><span class=arrow-icon></span></a>
<script>var mybutton=document.getElementById("scroll-top");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script></body></html>