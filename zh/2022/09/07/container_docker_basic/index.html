<!doctype html><html lang=zh itemscope itemtype=http://schema.org/WebPage><head><meta name=generator content="Hugo 0.110.0"><meta charset=utf-8><title>Docker 基础与实践 · Pseudoyu</title><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><script async defer data-website-id=058488c2-18d4-498a-b683-0a898b3f6c7a src=https://data.pseudoyu.com/pseudoyu.js></script>
<script async src=https://cdn.splitbee.io/sb.js></script>
<script src=https://cdn.splitbee.io/sb-ab.js></script>
<script src=https://www.pseudoyu.com/js/snow.js defer></script><meta name=description content="《后来的我们 - 五月天》 前言 这是工作实践系列容器部分的第一篇，主要介绍 Docker 的基础知识与实践。 作为一个后端开发，我刚开始工作的时候其实主要都是在本"><meta name=keywords content="hugo,blockchain,programming"><link rel=canonical href=https://www.pseudoyu.com/zh/2022/09/07/container_docker_basic/><link rel=alternate href=https://www.pseudoyu.com/en/2022/09/07/container_docker_basic/ hreflang=en><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css integrity=sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css integrity=sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ crossorigin=anonymous><link rel=stylesheet href=https://www.pseudoyu.com/css/den.css><link rel=stylesheet href=https://www.pseudoyu.com/css/custom.css><meta property="og:title" content="Docker 基础与实践"><meta property="og:description" content="《后来的我们 - 五月天》 前言 这是工作实践系列容器部分的第一篇，主要介绍 Docker 的基础知识与实践。 作为一个后端开发，我刚开始工作的时候其实主要都是在本"><meta property="og:type" content="article"><meta property="og:url" content="https://www.pseudoyu.com/zh/2022/09/07/container_docker_basic/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-07T01:30:48+08:00"><meta property="article:modified_time" content="2022-09-07T01:30:48+08:00"><meta itemprop=name content="Docker 基础与实践"><meta itemprop=description content="《后来的我们 - 五月天》 前言 这是工作实践系列容器部分的第一篇，主要介绍 Docker 的基础知识与实践。 作为一个后端开发，我刚开始工作的时候其实主要都是在本"><meta itemprop=datePublished content="2022-09-07T01:30:48+08:00"><meta itemprop=dateModified content="2022-09-07T01:30:48+08:00"><meta itemprop=wordCount content="3545"><meta itemprop=keywords content="container,docker,devops,programming,work practice series,work,practice,backend,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker 基础与实践"><meta name=twitter:description content="《后来的我们 - 五月天》 前言 这是工作实践系列容器部分的第一篇，主要介绍 Docker 的基础知识与实践。 作为一个后端开发，我刚开始工作的时候其实主要都是在本"></head><body><div class=header-container style=background:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2)),url(https://www.pseudoyu.com/images/background.webp);background-position:50%;background-size:cover><div class=container><nav class="header-nav navbar navbar-expand-md navbar-dark light-dark"><div class="header-logo navbar-brand"><a class=float-left href=https://www.pseudoyu.com/zh/><img class="mr20 header-logo-image" src=https://www.pseudoyu.com/images/fly.png alt=logo>
Pseudoyu</a></div><button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="nav-menu collapse navbar-collapse" id=navbarNav><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/category/ideas/>思考</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/category/tools/>工具</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/category/develop/>编程</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/links/>友链</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/about/>关于</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/zh/search/>搜索</a></li><li class=nav-item><a class=nav-link href=https://www.pseudoyu.com/en/><i class="fas fa-globe"></i> English</a></li></ul></div></nav></div><div class="container header-wrapper"><div class=row><div class=col-lg-12><div class=header-content><h1 class=header-title>Docker 基础与实践</h1><p class=header-date>作者:
pseudoyu
| <span>3545 字, 8 分钟</span>
| <span data-cusdis-count-page-id=773fa351cadb6ebe9b0fb502dd85f0ff>0</span> 评论
| 2022-09-07
| 分类:
<a href=https://www.pseudoyu.com/zh/category/develop/>Develop</a></p><div class=header-underline></div><div class=clearfix></div><p class="float-right header-tags"><i class="fas fa-tags" aria-hidden=true></i>
<a href=https://www.pseudoyu.com/zh/tag/backend/>backend</a>,
<a href=https://www.pseudoyu.com/zh/tag/container/>container</a>,
<a href=https://www.pseudoyu.com/zh/tag/devops/>devops</a>,
<a href=https://www.pseudoyu.com/zh/tag/docker/>docker</a>,
<a href=https://www.pseudoyu.com/zh/tag/practice/>practice</a>,
<a href=https://www.pseudoyu.com/zh/tag/programming/>programming</a>,
<a href=https://www.pseudoyu.com/zh/tag/work/>work</a>,
<a href=https://www.pseudoyu.com/zh/tag/work-practice-series/>work practice series</a></p><div class=clearfix></div><p class="float-right translations"><i class="fas fa-language" aria-hidden=true></i>
翻译:
<a href=https://www.pseudoyu.com/en/2022/09/07/container_docker_basic/>EN</a></p></div></div></div></div></div><main><div class="container content"><articl data-pagefind-body><figure><audio controls preload=metadata><source src=/audios/here_after_us.mp3 type=audio/mpeg></audio><i><figcaption>《后来的我们 - 五月天》</figcaption></i></figure><h2 id=前言>前言</h2><p>这是工作实践系列容器部分的第一篇，主要介绍 Docker 的基础知识与实践。</p><p>作为一个后端开发，我刚开始工作的时候其实主要都是在本地调试的，并没有怎么了解过 Docker 的相关使用。直到后来开始接触较为复杂的底层链开发，因为链或其相关工具的依赖关系比较复杂，也涉及很多版本冲突问题，在本机或服务器上每次需要配置复杂的环境，且每次重启后很多服务与配置都需要重新部署，繁琐且容易出现一些莫名的跨平台错误。</p><p>因此逐渐开始采用编写项目特定 Dockerfile 并编译镜像的方式进行后续的开发调试，部署的机器仅需安装 Docker 环境（以及 Docker Compose），而不需要本地安装各种依赖，很便捷。后续也和 Leader 一起基于 Docker 镜像、GitLab CI 与 k8s 环境配置了项目的 CI/CD 流程，极大提升了开发调试效率。</p><p>本文将基于这些经验对 Docker 相关的概念与实践进行总结，希望能有所帮助。</p><h2 id=docker-简介>Docker 简介</h2><p>我们所开发的服务往往以二进制的方式运行在操作系统中，而 Docker 是一种容器技术，将我们的应用程序及相关依赖打包在一个容器中，容器往往是基于一个较为轻量级的 Linux 镜像，是多层镜像的堆叠，我们的应用往往在最上层，这些依赖关系在 Dockerfile 中进行指定。</p><p>使用容器进行部署比起在本机或远程服务器有很多明显的优势。</p><ol><li>无需在操作系统上安装各类环境和依赖（除了 Docker 自身）。如果采用原有的服务启动模式，开发流程会变得十分繁琐，需要开发与运维不断沟通，配合完成环境配置与部署，并且如果一台机器上部署了多个服务，也极易造成依赖/版本冲突问题。</li><li>可以拥有独立的部署环境。我们通过为不同的项目编写 Dockerfile 来构建镜像，将应用所需环境与依赖打包在镜像中，可以很方便地运行同个应用的不同版本，或为 MySQL 这样的通用服务运行多个实例，并且可以通过 Docker 命令或 Docker Compose 命令进行管理，一键启动/暂停。</li><li>Docker 并不强依赖于操作系统本身的版本，同一个 Docker 镜像可以在不同的操作系统（Windows、macOS、不同发行版的 Linux）上运行，易于服务的分享、迁移与跨平台部署等。</li><li>与虚拟机相比，Docker 容器没有内核而只包含应用层，体积更小，启动速度更快，更加轻量级。</li></ol><p>当然，Docker 容器的兼容性相比操作系统与虚拟机相对更差一些，如 VM 能够运行任意其他操作系统，能满足更特定的一些需求。</p><h2 id=docker-基础操作>Docker 基础操作</h2><h3 id=安装-docker>安装 Docker</h3><p>Docker 的安装很简单，在<a href=https://www.docker.com>官网</a>下载自己操作系统对应的安装包并按照指引进行安装即可。</p><h4 id=macos>macOS</h4><p>我个人的 macOS 系统起初是安装了 <a href=https://www.docker.com/products/docker-desktop/>Docker Desktop</a>，可以通过图形化界面对镜像、容器进行管理，很方便但是占用较高，比较耗电。</p><p>后来尝试了 <a href=https://github.com/abiosoft/colima>Colima</a>，一个较为轻量级的容器运行环境，在 macOS 系统上本机调试十分方便，推荐使用，根据项目官方文档安装并配置环境即可。我直接通过 <code>brew</code> 包管理工具来进行安装：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>brew install colima
</span></span></code></pre></div><p>安装完成后运行 <code>colima start</code> 即可启动容器，运行 <code>colima stop</code> 停止容器，更多命令可以通过 <code>colima --help</code> 查看。</p><p>我通过了如下命令启动了自己的常用开发环境，大家可以根据自己的需求自行配置：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>colima start -c <span class=m>8</span> -m <span class=m>16</span> -a x86_64 -p docker-amd
</span></span></code></pre></div><h4 id=centos>CentOS</h4><p>比起本机开发，Docker 更常用的应用场景是在服务器上部署应用，我常用的操作系统是 <code>CentOS 7</code>，可以通过 <code>yum</code> 包管理工具安装：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>yum install -y yum-utils device-mapper-persistent-data lvm2
</span></span><span class=line><span class=cl>yum-config-manager  --add-repo https://download.docker.com/linux/centos/docker-ce.repo
</span></span><span class=line><span class=cl>yum install docker-ce
</span></span></code></pre></div><p>安装完成后，启动 Docker 服务并配置其开机自启：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>systemctl <span class=nb>enable</span> docker
</span></span><span class=line><span class=cl>systemctl start docker
</span></span></code></pre></div><h3 id=docker-镜像>Docker 镜像</h3><p>Docker 主要有镜像和容器两个概念，可以认为镜像是通过 Dockerfile 编译出来的容器的一个模板，而容器是镜像的一个实例。</p><h4 id=dockerfile>Dockerfile</h4><p>我们通过 Dockerfile 来指定应用所需环境与依赖，其基本格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> &lt;image&gt;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENV</span> <span class=nv>USERNAME</span><span class=o>=</span>admin <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=nv>PASSWORD</span><span class=o>=</span><span class=m>123456</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>RUN</span> mkdir -p &lt;app-directory&gt;<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . /&lt;app-directory&gt;<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;&lt;command&gt;&#34;</span><span class=p>,</span> <span class=s2>&#34;&lt;entrypoint file&gt;&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>完成 Dockerfile 编写后，我们可以在同级目录（或指定 Dockerfile）下通过 <code>docker build</code> 命令来构建镜像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 镜像构建</span>
</span></span><span class=line><span class=cl>docker build -t &lt;image:tag&gt; .
</span></span></code></pre></div><h4 id=存储加载镜像>存储、加载镜像</h4><p>我们可以把本地编译好的镜像存储为 <code>tar</code> 包来进行分享：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker save -o &lt;image-name&gt;.tar &lt;image-name&gt;
</span></span></code></pre></div><p>当需要使用镜像时则可以通过 <code>docker load</code> 命令来加载 tar 包：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker load -i &lt;image-name&gt;.tar
</span></span></code></pre></div><h4 id=上传拉取镜像>上传、拉取镜像</h4><p>当然，通过镜像 <code>tar</code> 包的方式来进行分享并不那么便捷，有的镜像可能会很大，传输也不方便。因此，我们可以通过 <code>docker push</code> 命令来将镜像推送至官方镜像仓库或企业/个人的私有库（像我所在的项目就是通过 Harbor 来管理镜像），并通过 <code>docker pull</code> 命令来进行拉取。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 拉取官方镜像（简写）</span>
</span></span><span class=line><span class=cl>docker pull &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 拉取官方镜像（完整命令）</span>
</span></span><span class=line><span class=cl>docker pull docker.io/library/&lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 推送镜像至官方镜像仓库 Docker Hub</span>
</span></span><span class=line><span class=cl>docker push &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 推送镜像至私有库（需要配置鉴权）</span>
</span></span><span class=line><span class=cl>docker tag &lt;image:tag&gt; &lt;private-repo-path&gt;/&lt;image:tag&gt;
</span></span><span class=line><span class=cl>docker push &lt;private-repo-path&gt;/&lt;image:tag&gt;
</span></span></code></pre></div><h4 id=docker-镜像操作>Docker 镜像操作</h4><p>针对 Docker 镜像，我常用到的操作就是查看、删除与重命名 tag，更多命令可以通过 <code>docker image --help</code> 或官网查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 查看所有镜像</span>
</span></span><span class=line><span class=cl>docker images
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 删除镜像</span>
</span></span><span class=line><span class=cl>docker rmi &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 重命名镜像</span>
</span></span><span class=line><span class=cl>docker tag &lt;old-image:tag&gt; &lt;new-image:tag&gt;
</span></span></code></pre></div><h3 id=容器操作>容器操作</h3><h4 id=查看容器>查看容器</h4><p>当我们通过 Docker 或 Docker Compose 命令启动镜像后，可以通过以下命令查看服务状态：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 查看运行中容器</span>
</span></span><span class=line><span class=cl>docker ps
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看所有容器</span>
</span></span><span class=line><span class=cl>docker ps -a
</span></span></code></pre></div><h4 id=通过镜像启动停止实例>通过镜像启动/停止实例</h4><p>当我们通过 Dockerfile 编译好了所需镜像后，可以通过 <code>docker run</code> 命令启动镜像实例，并在命令中加入一些配置来满足我们的服务需求，我的常用操作如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 运行容器</span>
</span></span><span class=line><span class=cl>docker run &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 运行容器并指定名称</span>
</span></span><span class=line><span class=cl>docker run --name &lt;server-name&gt; &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 以 detached 模式运行容器</span>
</span></span><span class=line><span class=cl>docker run -d &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 端口映射</span>
</span></span><span class=line><span class=cl>docker run -p6000:6379 &lt;image:tag&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 配置环境变量</span>
</span></span><span class=line><span class=cl>docker run -e <span class=nv>USERNAME</span><span class=o>=</span>admin -e <span class=nv>PASSWORD</span><span class=o>=</span><span class=m>123456</span> &lt;image:tag&gt;
</span></span></code></pre></div><h4 id=启动停止容器服务>启动/停止容器服务</h4><p>当我们通过镜像创建实例后，可以通过如下命令来启动/停止容器服务：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 启动/重启容器</span>
</span></span><span class=line><span class=cl>docker start &lt;container-id&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 暂停容器</span>
</span></span><span class=line><span class=cl>docker stop &lt;container-id&gt;
</span></span></code></pre></div><h4 id=查看日志>查看日志</h4><p>当我们的通过 Docker 启动服务后，还常常需要查看其运行日志以便于调试，可以通过 <code>docker logs</code> 进行查看，具体命令如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 查看日志</span>
</span></span><span class=line><span class=cl>docker logs &lt;container-id&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 滚动查看日志</span>
</span></span><span class=line><span class=cl>docker logs -f &lt;container-id&gt;
</span></span></code></pre></div><h4 id=进入容器>进入容器</h4><p>有时我们还需要进入 Docker 容器服务内部进行服务查看与调试，可以通过 <code>docker exec</code> 命令进入容器，具体命令如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 根据 id 进入特定容器</span>
</span></span><span class=line><span class=cl>docker <span class=nb>exec</span> -it &lt;container-id&gt; &lt;command&gt;
</span></span></code></pre></div><h4 id=docker-网络>Docker 网络</h4><p>Docker 容器实例运行于网络中，我们上文的各个命令未指定网络，所以服务会运行在默认网络下，我们可以通过以下命令来查看网络：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 查看所有网络</span>
</span></span><span class=line><span class=cl>docker network ls
</span></span></code></pre></div><p>如果不想运行在默认网络中，我们可以通过如下命令创建自定义网络：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 创建自定义网络</span>
</span></span><span class=line><span class=cl>docker network create &lt;network-name&gt;
</span></span></code></pre></div><p>创建了我们的自定义网络后，在创建容器实例时我们可以通过 <code>--network</code> 参数来指定网络：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run --network &lt;network-name&gt; &lt;image:tag&gt;
</span></span></code></pre></div><h4 id=docker-数据持久化>Docker 数据持久化</h4><p>使用 Docker 实例运行服务后，我们的数据会保存在容器中，当容器被删除后，数据也会被删除，对于一些需要长期运行的服务来说会造成数据丢失。因此，我们需要进行数据的持久化，我常用 host 挂载与 container 挂载两种方式。</p><p>我们可以通过将宿主机的某个具体的目录挂载映射至容器内的目录来实现持久化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 通过宿主机目录挂载容器内目录</span>
</span></span><span class=line><span class=cl>docker run -v &lt;host-file-path&gt;:&lt;container-file-path&gt; &lt;image:tag&gt;
</span></span></code></pre></div><p>也可以通过 container 挂载的方式，使用 volume 来实现持久化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 可以通过名字来引用 volume</span>
</span></span><span class=line><span class=cl><span class=c1># Docker 会自动生成一个路径</span>
</span></span><span class=line><span class=cl><span class=c1># Windows: C:\ProgramData\docker\volumes</span>
</span></span><span class=line><span class=cl><span class=c1># Linux: /var/lib/docker/volumes</span>
</span></span><span class=line><span class=cl><span class=c1># macOS: /var/lib/docker/volumes</span>
</span></span><span class=line><span class=cl>docker run -v &lt;volume-name&gt;:&lt;container-file-path&gt; &lt;image:tag&gt;
</span></span></code></pre></div><p>如果只是需要挂载，不需要对文件进行具体的管理查看等，我们也可以通过 container 匿名挂载的方式，不指定 volume 名称，而使用其自动生成的目录：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Docker 会自动生成一个路径</span>
</span></span><span class=line><span class=cl><span class=c1># Windows: C:\ProgramData\docker\volumes</span>
</span></span><span class=line><span class=cl><span class=c1># Linux: /var/lib/docker/volumes</span>
</span></span><span class=line><span class=cl><span class=c1># macOS: /var/lib/docker/volumes</span>
</span></span><span class=line><span class=cl>docker run -v &lt;container-file-path&gt; &lt;image:tag&gt;
</span></span></code></pre></div><h2 id=docker-compose>Docker Compose</h2><p>Docker 提供了丰富的命令供我们使用，但是使用命令行操作不易于记忆，且如果应用依赖多个环境/服务，则需要分别运行与管理多个容器，造成不便。因此，我们可以通过 Docker Compose 工具来进行管理。</p><p>Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具，其通过 <code>.yaml</code> 文件来进行配置管理。我在日常工作中使用最高频率的也是 Docker Compose，只有一些很简单的应用才会使用 <code>docker run</code> 命令来启动，也便于统一管理和后续的配置调整。</p><h3 id=安装>安装</h3><p>macOS 系统如果安装了 Docker Desktop 则已经自带了 Docker Compose，可以直接使用。如果是 Linux 系统则需要单独安装，我这里同样以 <code>CentOS 7</code> 为例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl -L <span class=s2>&#34;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-</span><span class=k>$(</span>uname -s<span class=k>)</span><span class=s2>-</span><span class=k>$(</span>uname -m<span class=k>)</span><span class=s2>&#34;</span> -o /usr/local/bin/docker-compose
</span></span><span class=line><span class=cl>chmod +x /usr/local/bin/docker-compose
</span></span><span class=line><span class=cl>ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
</span></span></code></pre></div><p>完成安装后就可以使用 <code>docker-compose</code> 命令了。</p><h3 id=配置管理>配置管理</h3><p>Docker Compose 的配置文件是一个 <code>yaml</code> 文件，其基本格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;3&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nt>contrainer-1</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    	</span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>&lt;image-name&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span>- <span class=l>&lt;host&gt;:&lt;container&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span>- <span class=l>&lt;host-file-path&gt;:&lt;container-file-path&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span><span class=l>&lt;ENV-KEY&gt;=&lt;ENV-VALUE&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>contrainer-2</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    	</span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>&lt;image-name&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span>- <span class=l>&lt;host&gt;:&lt;container&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span>- <span class=l>&lt;volume-name-1&gt;:&lt;container-file-path&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        	</span><span class=l>&lt;ENV-KEY&gt;=&lt;ENV-VALUE&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nt>volume-name-1</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    	</span><span class=nt>driver</span><span class=p>:</span><span class=w> </span><span class=l>local</span><span class=w>
</span></span></span></code></pre></div><p>其大部分配置都很直观，如服务名称、镜像名称、端口映射、文件挂载、环境变量等。</p><p>其中，<code>version</code> 表示配置文件的版本，<code>services</code> 表示服务列表，<code>volumes</code> 表示挂载的卷列表。</p><p>在具体的 <code>services</code> 中，<code>image</code> 表示镜像名称，<code>ports</code> 表示端口映射，<code>volumes</code> 表示文件挂载，<code>environment</code> 表示环境变量，更多配置可以根据项目需要进行查看。</p><h3 id=常用命令>常用命令</h3><h4 id=启动停止服务>启动/停止服务</h4><p>跟 <code>docker run</code> 命令类似，Docker Compose 也提供了 <code>up</code> 和 <code>down</code> 命令来启动和停止服务。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 启动服务</span>
</span></span><span class=line><span class=cl>docker-compose -f &lt;name&gt;.yaml up
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 以 detached 模式启动服务</span>
</span></span><span class=line><span class=cl>docker-compose -f &lt;name&gt;.yaml up -d
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 停止服务</span>
</span></span><span class=line><span class=cl>docker-compose -f &lt;name&gt;.yaml down
</span></span></code></pre></div><h4 id=查看日志-1>查看日志</h4><p>我们可以通过 <code>logs</code> 命令来查看服务的日志。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 查看日志</span>
</span></span><span class=line><span class=cl>docker-compose logs &lt;container-id&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 滚动查看日志</span>
</span></span><span class=line><span class=cl>docker-compose logs -f &lt;container-id&gt;
</span></span></code></pre></div><h2 id=实用操作命令>实用操作命令</h2><p>除了以上基础命令外，我常用的还有以下几个常用命令。</p><h3 id=清除无用容器>清除无用容器</h3><p>当我们因配置或程序运行时调用出错而导致容器实例退出时，其依然会保留，可以通过 <code>docker ps -a</code> 命令来查看，我们可以通过以下组合命令进行清理：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker rm <span class=sb>`</span>docker ps -a <span class=p>|</span> grep Exited <span class=p>|</span> awk <span class=s1>&#39;{print $1}&#39;</span><span class=sb>`</span>
</span></span></code></pre></div><h3 id=批量导入本地镜像>批量导入本地镜像</h3><p>当我们需要将大量本地镜像导入机器时，如果一个个导入会非常麻烦，我们可以将镜像放入同一个目录并通过以下命令进行批量导入：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=k>for</span> i in <span class=sb>`</span>ls<span class=sb>`</span><span class=p>;</span> <span class=k>do</span> docker load &lt; <span class=nv>$i</span> <span class=p>;</span> <span class=k>done</span>
</span></span></code></pre></div><h2 id=总结>总结</h2><p>以上就是我对 Docker 容器技术的基础知识与实用操作的讲解，希望对你有所帮助。其实 Docker 的内容还有很多，如在上一个项目中尝试用到 Docker 的 <code>Buildkit</code> 特性，极大减小了最终构建镜像的大小，以及使用到 <code>buildx</code> 来实现跨平台兼容等等，本文旨在讲解基础知识与实践中常用的命令，这些拓展部分如果大家感兴趣的话后续再进行更新。</p><h2 id=参考资料>参考资料</h2><blockquote><ol><li><a href=https://www.docker.com>Docker 官网</a></li><li><a href="https://www.youtube.com/watch?v=3c-iBn73dDE">Docker Tutorial for Beginners</a></li></ol></blockquote></articl><h2>相关文章</h2><dl class=row></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2022-09-05</dt><dd class=col-md-9><a href=/zh/2022/09/05/database_postgres_basic/>PostgreSQL 基础与实践</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><dt class=col-md-3>2021-03-29</dt><dd class=col-md-9><a href=/zh/2021/03/29/database_mysql_basic/>MySQL 基础与实践</a></dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl></dl><div class=author-card><div class=underline></div><div class=author-box><div class=author-image><a href=https://www.pseudoyu.com><img src=/images/author.webp alt=pseudoyu></a></div><div class=author-content><p class=author-title>作者</p><p class=author-name>pseudoyu</p><p class=author-desc>区块链开发工程师，HKU ECICer。喜欢探索新技术，空闲时也折腾 Logseq 等效率工具。 在 <a href=https://github.com/pseudoyu>GitHub</a> 关注我。在我的 <a href=https://t.me/pseudoyulife>Telegram 频道</a>了解更多。</p></div></div></div><div align=center><div class=comment-underline></div></div><br><div id=cusdis_thread data-host=https://comments.pseudoyu.com data-app-id=27a61667-fd43-4a0d-934d-f45b944489ee data-page-id=773fa351cadb6ebe9b0fb502dd85f0ff data-page-url=https://www.pseudoyu.com/zh/2022/09/07/container_docker_basic/ data-page-title="Docker 基础与实践"></div><script defer src=https://comments.pseudoyu.com/js/widget/lang/zh-cn.js></script>
<script async defer src=https://comments.pseudoyu.com/js/cusdis.es.js></script>
<script defer data-host=https://comments.pseudoyu.com data-app-id=27a61667-fd43-4a0d-934d-f45b944489ee src=https://comments.pseudoyu.com/js/cusdis-count.umd.js></script></div></main><div class="footer gradient-2"><div class="container footer-container"><div class=row><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>网站地图</div><ul class=list-unstyled><li><a href=https://www.pseudoyu.com/zh/tags/>标签</a></li><li><a href=https://www.pseudoyu.com/zh/categories/>分类</a></li><li><a rel=alternate type=application/rss+xml href=https://www.pseudoyu.com/zh/index.xml><i class="fas fa-rss-square"></i> RSS</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>社交</div><ul class=list-unstyled><li><a href=https://t.me/pseudoyulife rel=noopener target=_blank>Telegram</a></li><li><a href=https://twitter.com/pseudo_yu rel=noopener target=_blank>Twitter</a></li><li><a href=https://www.instagram.com/pseudo.yu/ rel=noopener target=_blank>Instagram</a></li><li><a href=https://space.bilibili.com/5374948/ rel=noopener target=_blank>BiliBili</a></li></ul></div><div class="col-xs-4 col-sm-3 col-md-3 col-lg-3"><div class=footer-title>关于</div><ul class=list-unstyled><li><a href=https://github.com/pseudoyu rel=noopener target=_blank>Yu's GitHub</a></li><li><a href=https://uptime.pseudoyu.com/status/services rel=noopener target=_blank>Yu's Services</a></li><li><a href=https://www.m1sty.com/ rel=noopener target=_blank>M1sty's Blog</a></li></ul></div><div class="col-xs-12 col-sm-3 col-md-3 col-lg-3"><p class="pull-right text-right"><small><em><a href=https://data.pseudoyu.com/share/8YKX7FUa/pseudoyu-blog rel=noopener target=_blank>Yu's blog analytics</a></em></small><br><small><em>Powered by <a href=https://gohugo.io rel=noopener target=_blank>Hugo</a> - <a href=https://github.com/shaform/hugo-theme-den rel=noopener target=_blank>den</a></em></small><br><small><em><a href=https://www.hku.hk rel=noopener target=_blank>The University of Hong Kong</a> - <a href=https://www.cs.hku.hk rel=noopener target=_blank>CS</a></em></small><br><small>&copy;
Yu Zhang
2020 -
2023</small></p></div><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" id=scroll-top class=scroll-top accesskey=g><span class=arrow-icon></span></a>
<script>var mybutton=document.getElementById("scroll-top");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script></body></html>